# Build Your Own 16-bit SuperPascal Computer: 6-Year Curriculum Roadmap

Executive Summary

This 6-year curriculum guides students (ages 13-18) through building a computer from first principles, culminating in a 16-bit Harvard-inspired game console based on the MOS 65C816 CPU. The curriculum is structured as a progressive journey: Years 1-2 (ages 13-14) establish foundational electronics and digital logic, Years 3-4 (ages 15-16) build an 8-bit breadboard CPU (inspired by Ben Eater's SAP-1 design) and enhance it, Year 5 (age 17) transitions to a 16-bit 65C816 microprocessor system with expanded memory and I/O, and Year 6 (age 18) integrates advanced video/audio and develops a complete software stack (assembly, a Pascal-based high-level language, and a simple OS/monitor). The final machine features a 65C816 running at modest MHz speeds with up to 16 MB addressable RAM  $\mathbb{1}$ , separate program ROM and data RAM (introducing a Harvard architecture concept), video output (progressing from simple text/serial output to graphics, optionally HDMI via a co-processor), sound generation (e.g. using a Yamaha YM2149F PSG or SAM2695 MIDI synthesizer), and mass storage (SD card or compact flash interface). Students will be able to write and run assembly and SuperPascal programs on this homemade console - for example, printing to a screen, controlling sprites, playing simple audio, and running game-loop logic.

This hands-on pathway offers a superior computer science and electronics education compared to a typical school computing course. Instead of treating computers as black boxes, students actively construct a computer and learn how each component works – from logic gates, flip-flops, and adders to CPU control logic and memory maps. They gain practical skills in electronics (breadboarding, soldering, PCB design, troubleshooting) and in programming across low-level assembly to high-level languages. By the final year, students appreciate how software translates to hardware operations, and even how a compiler and operating system are built. This deep understanding is rarely achieved in standard curricula focused only on abstract coding or application use. Moreover, the project-based, iterative approach ensures engagement: each term yields tangible results (blinking LED, a working arithmetic logic unit, a programmable 8-bit computer, etc.), keeping motivation high. The educational value has been recognized by industry – for example, Western Design Center's engineers have promoted 65xx-based projects in after-school clubs to teach low-level computing  $^{2}$ . A motivated A-level student completing this journey will not only be prepared for university-level engineering or computer science, but will also have a unique achievement (a custom 16-bit computer system) to showcase. Overall, this curriculum integrates CS theory and real-world engineering, fostering creativity, problem-solving, and a robust understanding of how modern computers and game consoles are built from the ground up.

What students build each year: In Years 1-2 (ages 13-14), students establish foundational electronics knowledge: basic circuits, logic gates, adders, registers, and buses. This early foundation reduces cognitive load during exam years. In Year 3 (age 15), students build a fully working 8-bit breadboard computer (SAP-1) with a manual control interface and simple output (LEDs or 7-segment displays). In Year 4 (age 16), they enhance the 8-bit system and prepare for the transition to 16-bit architecture. In Year 5 (age 17), they pivot to using the 65C816 microprocessor: designing a system around this 16-bit CPU with RAM, ROM, and I/O, first on breadboards then moving to schematic capture. In Year 6 (age 18), they fabricate printed circuit boards (PCBs) for a polished 16-bit computer / game console, integrating a graphics display (e.g. tile/sprite graphics on a monitor) and sound, and develop a basic OS/monitor, an assembler, and a SuperPascal runtime/compiler for the machine.

Final machine capabilities: The ultimate system (by end of Year 6) is a 65C816-based computer running at  $\sim 5 - 10$  MHz, with a 24-bit address bus (banked memory up to 16 MB)  $^{1}$ , at least 128 KB of RAM (expandable), and 32 KB or more of ROM containing a monitor program and system library. The system implements a **Harvard-inspired architecture** with separate program ROM and data RAM: program code resides in ROM (typically bank $FF), while data, stack, and heap use RAM (banks $00-$01, expandable). This separation provides security benefits (code cannot be accidentally overwritten) and allows different access patterns for code vs data, aligning with the 65C816's capabilities. It supports text and graphics output (initially via a serial terminal or LCD, and eventually a raster display or HDMI output through a video controller). It has sound output (e.g. 3-channel PSG sound chip or better) and input devices like a PS/2 keyboard or gamepad. The machine boots to a monitor prompt, allows assembly programs to be entered or loaded from an SD card, and can run compiled SuperPascal programs with a provided runtime library. In essence, it will function as a homemade retro-computer/game-conSOLE hybrid - capable of running simple games, demos with sprites and music, and user programs. The inclusion of a high-level language (SuperPascal) with an educational compiler extends the machine into a software development platform, distinguishing it from typical hobby 8-bit computers.

Why this pathway: Students get a uniquely comprehensive STEM experience: they design digital logic circuits, manage real-world issues like electronic noise and power distribution, and progressively abstract this knowledge into writing software for the machine they built. Compared to ordinary computing courses (which often focus on using existing computers or learn-to-code environments), this curriculum produces deeper understanding and retention. It emphasizes the connections between hardware and software – for instance, how high-level code eventually translates to machine instructions controlling circuits. It also instills good engineering practices (incremental development, testing, troubleshooting), teamwork, and project management over a multi-year project. By starting with simple components and ending with a functional 16-bit computer, students see the full spectrum of computing concepts in context. This not only prepares them for advanced studies, but also aligns with modern educational goals of experiential learning and computer systems transparency. In short, building a computer from scratch by age 18 is a transformative educational journey – one that makes abstract computing concepts concrete, sparks enthusiasm (who wouldn't be proud to play a game on a console they built themselves?), and produces future engineers with both practical and theoretical prowess.

# 6-Year Curriculum Roadmap (Ages 13-18: Pre-GCSE  $\rightarrow$  GCSE  $\rightarrow$  A-Levels)

The curriculum is organized by academic year (Year 1 through Year 6, ages 13-18) and further divided into terms and weeks. Each term focuses on a set of concepts and a tangible project outcome. The program is iterative: students start with fundamentals and progressively build subsystems that become part of the final computer. Every week has specific learning objectives, hands-on building tasks, experiments, and assessment artifacts. 

**Key Pedagogical Decision**: Foundational electronics and digital logic are taught in Years 1-2 (ages 13-14) to reduce cognitive load during GCSE and A-Level exam years. This allows Years 3-6 to focus on systems understanding, programming, and algorithms rather than frantic hardware building. Students enter GCSE years with solid hardware intuition, enabling deeper, calmer learning.

Throughout, we explicitly tie lessons to the SAP-1 (Simple-As-Possible 1) computer architecture and show how these concepts scale up to the 16-bit 65C816 system.

**Architecture Choice**: The curriculum uses the **65C816 microprocessor** (Western Design Center) due to modern availability and ease of access. The system implements a **Harvard-inspired architecture** with separate program ROM and data RAM, aligning with the 65C816's capabilities for banked memory addressing up to 16 MB.

**Language Strategy**: **Pascal (SuperPascal)** is the primary high-level language due to its educational value and easier access compared to other languages. Students will learn **assembly language** for understanding low-level operations, system programming (monitor, runtime), and interfacing, but the majority of application development will be in Pascal. This approach provides deep understanding of how high-level code translates to machine instructions while maintaining productivity for complex programs.

# Required Resources and References

## Primary Textbook: Years 1-3

**Digital Computer Electronics, Third Edition** by Albert Paul Malvino and Jerald A. Brown is the **primary textbook** for Years 1-3. This book provides complete coverage of digital logic principles and serves as the definitive reference for the SAP-1 computer architecture.

### Year 1-2: Digital Principles (Part 1, Chapters 1-9)
- **Chapter 1**: Number Systems and Codes - Required reading before Weeks 6-8
- **Chapter 2**: Gates - Required reading before Weeks 6-8
- **Chapter 3**: More Logic Gates - Required reading before Weeks 6-8
- **Chapter 4**: TTL Circuits - Reference for practical implementation
- **Chapter 5**: Boolean Algebra and Karnaugh Maps - Required reading before Weeks 9-12
- **Chapter 6**: Arithmetic-Logic Units - Required reading before Weeks 22-24
- **Chapter 7**: Flip-Flops - Required reading before Weeks 13-15
- **Chapter 8**: Registers and Counters - Required reading before Weeks 13-21
- **Chapter 9**: Memories - Required reading before Year 2 Term 1

### Year 1: Supplementary Practical Electronics Resource

**Practical Electronics for Inventors, Fourth Edition** by Paul Scherz and Simon Monk is a **supplementary resource** for Year 1, providing additional hands-on exercises and practical projects that make electronics learning more enjoyable and engaging.

**How to Use**: This book complements the Malvino & Brown textbook by providing:
- **Additional hands-on exercises** that reinforce concepts
- **Practical projects** that make learning fun
- **Real-world applications** of electronics principles
- **Troubleshooting tips** and practical techniques

**Integration**: Workshops based on this book are integrated throughout Year 1 (see `curriculum/Year1/workshops/` for detailed workshop activities). These workshops are **optional but highly recommended** for students who want extra practice and more engaging activities.

**Key Chapters for Year 1**:
- **Chapter 1**: Introduction to Electronics - Basic concepts, safety
- **Chapter 2**: Theory - DC circuits, Ohm's law, power
- **Chapter 3**: Basic Electronic Components - Resistors, capacitors, inductors, diodes
- **Chapter 4**: Semiconductors - Diodes, transistors (introduction)
- **Chapter 5**: Optoelectronics - LEDs, photodiodes, displays
- **Chapter 6**: Sensors - Light sensors, temperature sensors, switches
- **Chapter 7**: Hands-on Electronics - Breadboarding, soldering, troubleshooting
- **Chapter 8**: Operational Amplifiers - Op-amps (advanced, optional)
- **Chapter 9**: Filters - RC filters, timing circuits
- **Chapter 10**: Oscillators and Timers - 555 timer circuits, oscillators
- **Chapter 11**: Voltage Regulators and Power Supplies - Power management
- **Chapter 12**: Digital Electronics - Logic gates, flip-flops, counters (complements Malvino & Brown)

**Workshop Activities**: See `curriculum/Year1/workshops/PRACTICAL_ELECTRONICS_WORKSHOPS.md` for complete list of workshops based on this book. Workshops are designed to:
- **Reinforce curriculum concepts** through additional hands-on practice
- **Make learning enjoyable** with fun, engaging projects
- **Build directly toward computer construction** goals
- **Provide real-world applications** of electronics principles

**Workshop Examples**:
- **Term 1**: Voltage divider challenge, capacitor timing race, LED color mixing, logic gate detective game, binary calculator, multiplexer display system
- **Term 2**: Flip-flop memory game, Program Counter display, bus communication system, ALU challenge project
- **Cross-Term**: Power supply project, oscilloscope skills training

All workshops directly support Year 1 learning objectives and can be run as optional enrichment, extended lab sessions, homework projects, or club activities.

### Year 3: SAP-1 Construction (Part 2, Chapter 10)
- **Chapter 10: SAP-1** - **Mandatory reading** before Year 3 Term 1
  - Section 10-1: Architecture - Reference for data path design
  - Section 10-2: Instruction Set - Reference for instruction format
  - Section 10-3: Programming SAP-1 - Examples and programming patterns
  - Section 10-4: Fetch Cycle - Core concept for control unit
  - Section 10-5: Execution Cycle - Detailed instruction execution
  - Section 10-6: SAP-1 Microprogram - Implementation guide for microcode ROM
  - Section 10-7: SAP-1 Schematic Diagram - **Primary build reference**
  - Section 10-8: Microprogramming - Advanced control concepts

## Additional References: Years 4-6

### Year 4: Enhanced 8-bit Systems and 16-bit Transition
- **Malvino & Brown, Chapters 11-12** (SAP-2, SAP-3) - **Conceptual reference** for understanding CPU enhancements
  - Chapter 11 (SAP-2): Bidirectional registers, jump instructions, call/return, register instructions, logic instructions
  - Chapter 12 (SAP-3): Extended registers, indirect addressing, stack instructions
  - **Note**: While we don't build SAP-2/SAP-3, these chapters explain the educational concepts (jumps, subroutines, stacks, indirect addressing) that students will implement using the 65C816's native instruction set
- General microprocessor concepts from Part 3 (Chapters 13-14) - Supplementary reading

### Year 5-6: 65C816 Microprocessor System

**Required 65C816 Documentation** (students must have access to):
- **Western Design Center W65C816 Datasheet** - Primary hardware reference
- **65C816 Programming Manual** - Instruction set, addressing modes, native/emulation modes
- **65xx Family Instruction Set Reference** - Complete instruction reference
- **Harvard Architecture Concepts** - Supplementary materials on separate program/data memory
- **Memory Banking Documentation** - 24-bit addressing, bank switching (16 MB addressable)

**Assembly Language Resources**:
- **CC65 Toolchain Documentation** (ca65 assembler for 65C816) - Cross-development toolchain
- **65C816 Assembly Language Guide** - Syntax, addressing modes, programming patterns
- **65C816 Instruction Set Reference** (see `docs/65C816_INSTRUCTION_SET_REFERENCE.md`) - Complete instruction set organized by categories, complements Malvino & Brown Chapters 16-23
- **65C816 Concept Bridging Guide** (see `curriculum/Year4/Term2/65C816_CONCEPT_BRIDGING.md`) - Maps book concepts (from 6502, 6800, 8080/8085, 8086/8088 examples) to 65C816 equivalents, provides translation exercises and comparison tables
- **Malvino & Brown, Chapters 16-23** (Instruction Sets) - Conceptual reference for instruction categories (data transfer, arithmetic, logic, branches, etc.) using different CPUs as examples. Use for conceptual understanding, then apply to 65C816-specific instructions using the bridging guide.
- **Note**: Assembly is taught for understanding low-level operations, system programming (monitor, runtime library), and hardware interfacing. Most application development uses Pascal.

**Pascal/Compiler Resources**:
- **SuperPascal Language Specification** (based on Per Brinch Hansen's SuperPascal)
- **Compiler Design References** - For understanding code generation
- **Pascal Runtime Library Documentation** - System calls, I/O, memory management

**Operating System Resources**:
- **Operating System Design References** - For PascalOS development
- **Monitor/Bootloader Examples** - Apple I Wozmon, Kim-1 monitor as inspiration

**Hardware References**:
- **Video and Audio Hardware Reference** (see `curriculum/Year6/VIDEO_AUDIO_HARDWARE_REFERENCE.md`) - Comprehensive coverage of YM2149F PSG, SAM2695 MIDI synthesizer, video controllers (TMS9918/V9938/V9958, microcontroller solutions), integration guides, programming examples, and datasheet references. Note: VERA FPGA is not used as it is a black box that limits educational value.
- **YM2149F PSG Datasheet** - Sound chip documentation (linked in hardware reference)
- **SAM2695 MIDI Synthesizer Datasheet** - Advanced sound (linked in hardware reference)
- **Video Controller Documentation** - For graphics hardware integration (linked in hardware reference)
- **SD Card Interface Specifications** - Mass storage interface

## Reference Availability

All required resources should be available in:
- School/library digital resources
- Project website/documentation repository
- Offline copies for students without internet access
- Lab computers with pre-installed toolchains (CC65, etc.)

# Year 1 - Computing Foundations & Physical Logic (Age 13)

**Outcome**: Students understand hardware intuitively before touching CPUs. No programming pressure. This can be delivered as an after-school club, elective module, enrichment track, or pre-GCSE option.

## Term 1: Electronics Basics and Lab Skills (Weeks 1-12)

- Weeks 1-2: Introduction to the Lab & Safety. Objectives: Learn to use a breadboard, power supply, and multimeter. Understand voltage, current, resistance (Ohm's law) and the basics of DC circuits. Activities: Build a simple LED circuit (5 V supply, resistor, LED) to learn about current limiting. Verify voltages with a multimeter. Assessment: Students document the LED lighting with correct resistor, and answer questions on why a resistor is needed (preventing overcurrent that could burn out an LED/chip)  ${}^{3}$  .

- Weeks 3-5: Basic Components - Resistors, Capacitors, 555 Timer. Objectives: Understand RC timing, debouncing, and clock generation. Activities: Build a 555 timer in astable mode as a clock (blinking LED)  $④$ . Adjust frequency with a potentiometer and measure with a multimeter or oscilloscope. Build a simple debouncer for a push-button (using an RC network and Schmitt trigger). Assessment: Provide oscilloscope traces or timing diagrams showing a debounced vs. raw button signal, and a variable clock signal (e.g. 1 Hz to 1 kHz range via potentiometer).  

- Weeks 6-8: Switches and Boolean Logic. Objectives: Learn truth tables for basic logic gates (AND, OR, NOT, NAND, NOR, XOR). Activities: Using discrete logic ICs (e.g. 74HC08 AND, 74HC32 OR, 74HC04 inverter), wire up gates on breadboards. Verify their truth tables by manual inputs (toggle switches for logic 0/1) and LED outputs. Also create a simple diode-logic OR gate to illustrate gate construction 5 . **Required Reading**: Malvino & Brown, Chapters 1-3 (Number Systems, Gates, More Logic Gates) must be read before this week block. Assessment: Completed truth tables for each gate (student measured vs. expected), and a short quiz on Boolean algebra simplification.  

- Weeks 9-12: Combinational Logic Circuits. Objectives: Apply logic gates to create functional circuits (half-adder, full-adder, multiplexers, decoders). Activities: Build a 1-bit half-adder from gates, then a 4-bit ripple-carry adder using 74HC283 or discrete half-adders. Introduce binary and demonstrate 4-bit addition with LEDs showing binary sum and carry. Build a 2-to-1 multiplexer from gates, then use a 74HC157 quad MUX to select between two 4-bit inputs. If time, build a 2-to-4 decoder (74HC139 or from gates) and discuss how it could select memory or I/O devices. **Required Reading**: Malvino & Brown, Chapter 5 (Boolean Algebra and Karnaugh Maps) must be read before this week block. Assessment: Lab check that the 4-bit adder outputs correct sums (e.g.  $7 + 9 = 0 \times 10$  with carry). Students save oscilloscope or logic analyzer screenshots for one addition operation's carry propagation. They also answer a reflection: "How would a computer use a multiplexer in choosing between two data sources on a bus?"

### Term 1 Assessment

**Formative Assessments:**
- Weekly practical work and lab reports
- Safety quiz (Week 1-2)
- Component identification and measurement exercises
- Truth table verification for logic gates
- Circuit documentation and photos

**Summative Assessments:**
- **Week 3-5 Project**: 555 Timer Clock Circuit - Students build and demonstrate a working clock with variable frequency, submit oscilloscope traces or timing diagrams
- **Week 6-8 Project**: Logic Gate Verification - Students complete truth tables for all gates and take a Boolean algebra quiz
- **Week 9-12 Project**: Combinational Logic Circuit - Students build and test a 4-bit adder, submit logic analyzer screenshots and reflection on multiplexer usage

**Term Project:**
- Portfolio documentation of all circuits built during Term 1
- Written report explaining how basic components work together
- Demonstration of working circuits to instructor

## Term 2: Sequential Logic and Building Blocks (Weeks 13-24)

- Weeks 13-15: Flip-Flops and Registers. Objectives: Understand memory elements (SR latch, D flip-flop) and clocked storage. Activities: Build an SR latch from NOR gates. Then use 74HC74 ICs (dual D flip-flops) to create a 4-bit register (chain of flip-flops). Connect LED indicators to see the stored 4-bit value. Clock the register using the 555 timer or a debounced manual clock. Demonstrate loading a binary value (via DIP switches on D inputs) on a clock edge. **Required Reading**: Malvino & Brown, Chapter 7 (Flip-Flops) must be read before this week block. Assessment: Students provide a timing diagram showing D inputs vs stored Q outputs on clock transitions (either drawn or captured by a logic analyzer).

- Weeks 16-18: Binary Counters and the Program Counter concept. Objectives: Learn how counters work and their role as a PC (Program Counter). Activities: Use a 74HC161 or 74HC163 4-bit binary counter IC to build a modulo-16 counter (mimicking the SAP-1 program counter which counts 0-15)  $^{6}$ . Add a pushbutton to manually clock it and observe the binary count on LEDs. Also wire the counter's output to a 7-segment display (through a decoder or microcontroller) to show the count in decimal or hex for clarity. **Required Reading**: Malvino & Brown, Chapter 8 (Registers and Counters) - Sections on counters must be read before this week block. Assessment: Short worksheet: given a sequence of clock pulses, what is the counter's state? And vice-versa. Also, students must reset the counter and demonstrate it wrapping from 1111 back to 0000 (observing that 4-bit limit).

- Weeks 19-21: System Buses and Tri-State Buffers. Objectives: Understand how a shared bus works and why tri-state or bus transceivers are needed to avoid conflicts. Activities: Create a simple 4-bit bus with two registers (built from 74HC173 or 74HC574 latch ICs). Use tri-state outputs or 74HC125/244 buffers to allow only one register to put data on the bus at a time. Demonstrate by loading different values in the two registers and using control signals to output one or the other onto the LED-connected bus  $^{7}$ . Emulate a simplified SAP-1 bus: e.g., Register A and Register B output lines with control signals AO and BO (B-out) controlling their connection to the bus  $^{8}$ . **Required Reading**: Malvino & Brown, Chapter 8 (Registers and Counters) - Section 8-9 "Bus-Organized Computers" must be read before this week block. Assessment: Lab observation of correct bus operation (no contention - e.g., when A's output is enabled, B's must be off). Students record a truth table of control signals vs which register's value appears on the bus. They also note the consequence of accidentally enabling both (and why that must be avoided).

- Weeks 22-24: Putting It Together – Simple ALU Subsystem. Objectives: Combine adder and registers to form an ALU that can add or subtract two 4-bit numbers, akin to SAP-1's limited ALU. Activities: Use the earlier 4-bit adder and connect Register A and Register B outputs to its inputs via the bus. Introduce a subtraction control: e.g., use an XOR gate on the B input lines plus a conditional carry-in to do two's-complement subtraction (simulate SAP-1's SUB control by inverting B and adding 1 when SUB signal is active) 7 . Build a Flags flip-flop for Carry and Zero: capture the carry out of the adder and a NOR of the result bits for zero, on each operation 10 . Test the ALU by manually loading values into A and B and performing an ADD or SUB operation, then latching the result back into A. **Required Reading**: Malvino & Brown, Chapter 6 (Arithmetic-Logic Units) must be read before this week block. Assessment: Students produce a short "ALU demo" report: e.g., "5 + 3 = 8 (Carry=0, Zero=0); 8 - 8 = 0 (Carry=1 (borrow), Zero=1)" with photos or logic traces. This verifies their ALU and flags are working. At this stage, students have essentially built the core data path of an SAP-1 computer (minus control and memory). We connect these concepts explicitly: e.g., the SAP-1's A register, B register, adder, and flags are now in place 10 .

### Term 2 Assessment

**Formative Assessments:**
- Weekly practical work and lab reports
- Timing diagram exercises for flip-flops and registers
- Counter state analysis worksheets
- Bus operation verification exercises

**Summative Assessments:**
- **Week 13-15 Project**: Register System - Students build and demonstrate a 4-bit register with timing diagrams showing clock transitions
- **Week 16-18 Project**: Program Counter - Students build a modulo-16 counter, complete worksheets on counter behavior, and demonstrate wrap-around
- **Week 19-21 Project**: Bus System - Students build a tri-state bus system, record truth tables, and document bus contention consequences
- **Week 22-24 Project**: ALU Subsystem - Students produce an ALU demo report with test cases, photos, and logic traces showing addition, subtraction, and flag operations

**Term Project:**
- Complete data path demonstration: Students integrate all Term 2 components (registers, counters, bus, ALU) into a working subsystem
- Written report explaining how sequential logic enables computation
- Portfolio documentation of all sequential circuits

**Year 1 Summary**: By the end of Year 1, students understand how information is represented, what "state" means, why clocks exist, and how binary works physically. They have built LED circuits, clocks, logic gates, adders, registers, and simple state machines. No CPUs yet. No programming pressure.

---

# Year 2 - Computing Foundations & Physical Logic (Continued) (Age 14)

**Outcome**: Students consolidate their electronics knowledge and prepare for CPU construction. They understand the building blocks that will become a computer.

## Term 1: Advanced Logic and Memory Concepts (Weeks 1-12)

- Weeks 1-4: Memory Concepts and Simple Storage. Objectives: Introduce memory chips and how data is stored/retrieved. Activities: Use simple memory chips like 74LS189 or an 8-bit EEPROM (e.g. 28C16) configured for small address spaces. Create a Memory Address Register using two 4-bit registers (74HC173) to hold an 8-bit address. Use DIP switches or an Arduino-based EEPROM programmer to load simple data into memory. Connect the MAR to the address pins of memory, and the memory's data output to the bus via tri-state buffer. **Required Reading**: Malvino & Brown, Chapter 9 (Memories) must be read before this week block. Assessment: Students successfully store and retrieve data from memory: e.g., manually set MAR to an address, see that the byte at that address appears on the bus when enabled. They document the read operation timing.

- Weeks 5-8: Control Concepts and State Machines. Objectives: Understand how control signals orchestrate operations. Activities: Build simple state machines using counters and decoders. Create a 2-step or 4-step sequencer that generates control signals in sequence. Use this to control a simple operation like "load A, load B, add, store result". This introduces the concept of microcode sequencing without the full complexity. Assessment: Students demonstrate a working state machine that performs a sequence of operations correctly.

- Weeks 9-12: Integration and Review. Objectives: Review all concepts from Years 1-2 and prepare for CPU construction. Activities: Students build a complete "manual computer" - they can manually control all the signals to perform operations. This reinforces understanding of how all the pieces fit together. Assessment: Students demonstrate they can manually execute a simple program (e.g., load two numbers, add them, store result) by controlling all signals manually.

### Term 1 Assessment

**Formative Assessments:**
- Weekly practical work and lab reports
- Memory operation documentation exercises
- State machine design exercises
- Control signal sequencing practice

**Summative Assessments:**
- **Week 1-4 Project**: Memory Subsystem - Students successfully store and retrieve data from memory, document read operation timing, and demonstrate MAR functionality
- **Week 5-8 Project**: State Machine and Control - Students build and demonstrate a working state machine that performs a sequence of operations correctly
- **Week 9-12 Project**: Manual Computer Integration - Students demonstrate they can manually execute a simple program by controlling all signals, showing complete understanding of system integration

**Term Project:**
- Complete manual computer demonstration with written report
- Portfolio documentation of memory and control systems
- Presentation explaining how all Year 1-2 components work together

## Term 2: Advanced Control Systems and I/O (Weeks 13-21)

**Outcome**: Students extend control concepts and learn to interface with external devices, building more complex state machines and understanding microcode concepts.

**Note**: Term 2 is compressed to 9 weeks (from 12 weeks) while preserving all content.

- Weeks 13-15: Advanced State Machines and Microcode. Objectives: Design and build complex state machines, understand microcode ROM concepts, and implement instruction decoding. Activities: Build more sophisticated state machines with multiple operation types and conditional state transitions. Introduce microcode ROM concepts using EEPROM - students learn that microcode stores control sequences in ROM, where each instruction has a microcode sequence that generates control signals. Build a simple microcode ROM system: use EEPROM to store control signal patterns, where address = instruction opcode + microstep, and data = control signals for that step. Implement basic instruction decoding where upper address bits represent instruction opcode and lower bits represent microstep counter. Optimize control signal generation for efficiency. Assessment: Students demonstrate a working microcode ROM system that can generate control signals for at least two different operations. They document the microcode address formation and show how different instructions map to different control sequences. They build a complex state machine that performs multiple operations correctly.

- Weeks 16-18: Address Decoding and Memory Mapping. Objectives: Understand address decoding for multiple devices, design memory maps, and implement chip select generation. Activities: Learn the problem: multiple devices (memory chips, I/O devices) share one address bus, so we need to select which device responds. Implement address decoding logic using decoders (74HC138, 74HC139) to generate chip select signals. Design memory maps: higher address bits select device, lower address bits select location within device. Build systems with multiple memory chips, each responding to different address ranges. Understand memory-mapped I/O: treat I/O devices as memory locations. Create example memory maps showing which addresses correspond to which devices, considering size, alignment, gaps for expansion, and I/O space. Assessment: Students design and implement an address decoding system for at least 4 devices. They create a memory map table showing address ranges for each device. They demonstrate that writing to different address ranges correctly accesses different devices without conflicts.

- Weeks 19-21: Input/Output Systems. Objectives: Understand I/O device interfacing, design simple input and output interfaces, and implement I/O timing and synchronization. Activities: Learn I/O device basics: input devices (switches, buttons, sensors) provide data to the system, output devices (LEDs, displays, motors) display or act on data. Build simple input interfaces: connect switches and buttons to the bus via tri-state buffers, implement debouncing (from Year 1), read input as memory location. Build simple output interfaces: connect LEDs and 7-segment displays to the bus, use latches to hold output values, implement data direction control. Understand memory-mapped I/O: I/O devices appear as memory locations, address decoder selects I/O device, CPU reads/writes to I/O as if it were memory. Implement I/O timing: ensure proper timing between address, data, and control signals, handle synchronization issues. Assessment: Students build a complete I/O system with at least one input device (switches) and one output device (LEDs or 7-segment display). They demonstrate reading input and writing output through memory-mapped I/O. They document the I/O map showing which addresses correspond to which I/O devices.

### Term 2 Assessment

**Formative Assessments:**
- Weekly practical work and lab reports
- State machine design exercises
- Address decoding design exercises
- I/O interface design exercises

**Summative Assessments:**
- **Week 10-12 Project**: Advanced State Machine and Microcode - Students demonstrate working microcode ROM system, document microcode address formation, and build complex state machine performing multiple operations
- **Week 13-15 Project**: Address Decoding and Memory Mapping - Students design and implement address decoding for multiple devices, create memory map tables, and demonstrate conflict-free device access
- **Week 16-18 Project**: I/O Systems - Students build complete I/O system with input and output devices, demonstrate memory-mapped I/O operations, and document I/O map

**Term Project:**
- Complete advanced system demonstration with state machines, address decoding, and I/O
- Written report explaining advanced control systems and I/O concepts
- Portfolio documentation of all Term 2 systems
- Presentation demonstrating advanced system capabilities

## Term 3: Advanced Integration and System Optimization (Weeks 22-30)

**Note**: Term 3 is compressed to 9 weeks (from 12 weeks) while preserving all content.

**Outcome**: Students execute complex programs, optimize system performance, and prepare comprehensively for Year 3 CPU construction.

- Weeks 19-21: Complex Program Execution. Objectives: Execute complex multi-step programs manually, design programs with conditional operations and loops, and understand program design principles. Activities: Design and execute multi-operation programs that perform sequences of operations (load, compute, store, repeat). Implement conditional operations conceptually: understand how decisions could be made (e.g., if result is zero, do one thing; otherwise, do another). Execute loops and iterations manually: repeat operations multiple times, understand loop concepts. Perform data manipulation sequences: move data between locations, transform data, combine data from multiple sources. Learn program design and planning: break down complex tasks into steps, design control sequences, plan data flow. Assessment: Students design and manually execute a complex program (e.g., find maximum value in a list, sort numbers, compute factorial). They document the program steps, control signals needed, and demonstrate successful execution. They show understanding of program structure and flow.

- Weeks 22-24: System Optimization and Debugging. Objectives: Optimize system performance and reliability, debug complex hardware issues systematically, and understand advanced system concepts. Activities: Improve signal integrity: add decoupling capacitors, reduce wire lengths, improve power distribution, minimize noise. Optimize timing: ensure proper signal timing, eliminate race conditions, optimize clock distribution. Improve power distribution: ensure adequate power supply, reduce voltage drops, add bulk capacitors. Learn debugging methodologies: systematic approach to finding problems, use of test equipment (multimeter, oscilloscope, logic analyzer), divide and conquer techniques. Practice systematic troubleshooting: start with simple tests, isolate problems, verify fixes, document solutions. Assessment: Students identify and fix at least one system issue (timing, signal integrity, or power). They document the problem, debugging process, solution, and verification. They demonstrate improved system reliability and performance.

- Weeks 28-30: Final Integration and Year 3 Preparation. Objectives: Complete system review, create advanced documentation, prepare for Year 3, and complete portfolio. Activities: Conduct complete system review: verify all components work together, test all functionality, identify any remaining issues. Create advanced documentation: system architecture diagrams, component specifications, operation manuals, troubleshooting guides. Prepare system presentation: demonstrate complete system capabilities, explain all components, show complex program execution. Prepare for Year 3: review all Year 1-2 concepts, understand what will be needed for CPU construction, identify any knowledge gaps. Complete portfolio: compile all work from Years 1-2, include photos, schematics, test results, programs, documentation. Assessment: Students produce complete system portfolio with all documentation. They present their complete system demonstrating all capabilities. They complete Year 3 readiness assessment showing they understand all prerequisites.

### Term 3 Assessment

**Formative Assessments:**
- Weekly program execution exercises
- Optimization practice
- Debugging exercises
- Documentation progress reviews

**Summative Assessments:**
- **Week 22-24 Project**: Complex Program Execution - Students design and manually execute complex programs, document program steps and control signals, demonstrate successful execution
- **Week 25-27 Project**: System Optimization and Debugging - Students identify and fix system issues, document debugging process and solutions, demonstrate improved system reliability
- **Week 28-30 Project**: Final Integration and Year 3 Preparation - Students produce complete system portfolio, present complete system, complete Year 3 readiness assessment

**Term Project:**
- Complete system portfolio with all Years 1-2 work
- Advanced system documentation (architecture, specifications, manuals)
- System presentation demonstrating all capabilities
- Year 3 readiness verification

**Year 2 Summary**: By the end of Year 2 (Weeks 1-30), students have a complete understanding of the hardware building blocks. They know electronics, logic, memory, control concepts, advanced state machines, microcode concepts, address decoding, I/O systems, complex program execution, and system optimization. They can execute complex programs manually, debug hardware issues systematically, and optimize system performance. They are ready to build a CPU because they understand what each component does and how they all work together. This foundation makes Years 3-6 much calmer and deeper.

---

# Year 3 - CPU Construction (Age 15-16)

*Note: Students now enter with solid hardware foundations from Years 1-2. Year 3 focuses on building the complete SAP-1 8-bit CPU.*

## Term 1: SAP-1 Construction - Data Path (Weeks 1-9)

**Outcome**: Students build the complete data path of the SAP-1 CPU, integrating all Year 1-2 knowledge to construct the core computing elements: ALU, registers, buses, and memory subsystem.

**Required Reading**: **Malvino & Brown, Chapter 10 (SAP-1)** is **mandatory reading** before Year 3 Term 1. Students must read the entire chapter, with special attention to Section 10-1 (Architecture) and Section 10-7 (Schematic Diagram) which serve as the primary build reference.

- Weeks 1-3: Review and ALU Subsystem. Objectives: Review all Year 1-2 concepts relevant to CPU construction and build the Arithmetic Logic Unit (ALU) subsystem. Activities: Begin with a comprehensive review of combinational logic (adders), sequential logic (registers, flip-flops), binary arithmetic, and two's complement representation. Build a 4-bit adder/subtractor using 74HC283 or discrete half-adders. Implement subtraction using two's complement (invert B and add 1). Build a Flags register to capture Carry and Zero flags from ALU operations. Integrate the ALU with temporary registers to test operations. Use LEDs to display ALU inputs, outputs, and flags. **Reference**: Malvino & Brown, Chapter 10, Section 10-1 (Architecture) for SAP-1 data path overview. Assessment: Students demonstrate the ALU performing addition and subtraction operations correctly, with proper flag generation. They produce test results showing operations like "5 + 3 = 8 (Carry=0, Zero=0)" and "8 - 8 = 0 (Carry=1, Zero=1)" with photos or logic traces. This verifies the ALU and flags are working correctly.

- Weeks 4-6: Register File and Buses. Objectives: Build Register A and Register B for SAP-1, implement tri-state bus connections, and establish bus control logic. Activities: Construct Register A (primary accumulator) and Register B (secondary register) using 74HC173 or 74HC574 latch ICs. Both registers are 4-bit width to match SAP-1 design. Implement tri-state outputs so registers can be selectively connected to the data bus. Build bus control logic with control signals: AI (A In - load from bus), AO (A Out - output to bus), BI (B In), BO (B Out). Test register operations: load values from bus, output values to bus, verify no bus contention when both outputs are disabled. Connect registers to ALU inputs via the bus. Assessment: Students demonstrate correct bus operation with no contention (when A's output is enabled, B's must be off). They record a truth table of control signals vs which register's value appears on the bus. They test loading values into A and B, performing ALU operations, and storing results back to A - verifying the complete register-ALU-register data path.

- Weeks 7-9: Memory Subsystem. Objectives: Build the Memory Address Register (MAR) and connect memory chip to the system, completing the data path. Activities: Construct the MAR using 74HC173 (4-bit register) to hold the address of memory location to access. For SAP-1, use 4-bit addressing (16 bytes: addresses 0x0 to 0xF). Connect memory chip (74LS189 RAM or 28C16 EEPROM configured for 16-byte address space). Implement address decoding and connect MAR to memory address pins. Connect memory data output to bus via tri-state buffer with control signal RO (RAM Out). Test read operations: load address into MAR, enable RO, verify data appears on bus. Test write operations if using RAM: load address into MAR, place data on bus, assert write enable (WE). Integrate memory with complete data path: demonstrate loading data from memory into Register A, performing ALU operation, and storing result back to memory. Assessment: Students successfully store and retrieve data from memory. They document the read operation timing (MAR loaded, then RO asserted) and verify it matches SAP-1 sequence. They demonstrate a complete data path operation: load value from memory address 0xE into Register A, add value from memory address 0xF into Register B, perform addition, store result back to memory. This verifies the complete data path is integrated and functional.

### Term 1 Assessment

**Formative Assessments:**
- Weekly module testing and integration checkpoints
- ALU operation verification exercises
- Bus protocol testing
- Memory operation documentation

**Summative Assessments:**
- **Week 1-3 Project**: ALU Subsystem - Students demonstrate ALU performing addition and subtraction with correct flag generation, submit test results with photos/logic traces
- **Week 4-6 Project**: Register File and Buses - Students demonstrate correct bus operation, record control signal truth tables, and verify complete register-ALU-register data path
- **Week 7-9 Project**: Memory Subsystem - Students successfully store/retrieve data from memory, document timing, and demonstrate complete data path operations with memory integration

**Term Project:**
- Complete data path demonstration: Students integrate all Term 1 components (ALU, registers, bus, memory) into a working subsystem
- Written report explaining how data flows through the CPU data path
- Portfolio documentation with photos, schematics, and test results
- Presentation demonstrating complete data path functionality

## Term 2: SAP-1 Construction - Control Unit (Weeks 10-18)

**Outcome**: Students build the control unit for the SAP-1 CPU, constructing the program counter, instruction register, microcode ROM, and control signal generation to automate CPU operations.

**Required Reading**: **Malvino & Brown, Chapter 10** - Sections 10-2 (Instruction Set), 10-4 (Fetch Cycle), 10-5 (Execution Cycle), 10-6 (SAP-1 Microprogram), and 10-8 (Microprogramming) must be read before this term.

- Weeks 10-12: Program Counter and Instruction Register. Objectives: Build the Program Counter (PC) and Instruction Register (IR) to enable automatic instruction fetching. Activities: Construct the Program Counter using 74HC161 or 74HC163 4-bit binary counter ICs. The PC counts from 0 to 15 (4-bit addressing for SAP-1's 16-byte memory). Add increment control (CE - Count Enable) and reset capability. Connect PC output to bus via tri-state buffer with control signal CO (Counter Out). Build the Instruction Register using 74HC173 (8-bit register: 4-bit opcode + 4-bit operand). Connect IR to bus for loading instructions. Wire IR's upper 4 bits (opcode) for instruction decoding. Test instruction fetching: manually set PC to an address, enable CO to put address on bus, load into MAR, read memory, load instruction into IR. **Reference**: Malvino & Brown, Chapter 10, Section 10-4 (Fetch Cycle) for detailed fetch sequence. Assessment: Students demonstrate the PC counting correctly and outputting addresses to the bus. They show the IR loading instructions from memory and displaying the opcode. They document the instruction fetch sequence: PC → MAR → Memory → IR, verifying each step with logic analyzer or LEDs.

- Weeks 13-15: Microcode ROM System. Objectives: Design and build the microcode ROM system to generate control signals automatically for each instruction. Activities: Design the microcode format: each instruction needs a sequence of micro-instructions, each micro-instruction generates control signals (MI, RI, RO, AI, AO, BI, BO, EO, etc.). Build a microinstruction counter (2-bit or 3-bit counter) to step through micro-instructions. Use EEPROMs (28C16 or similar) to store microcode - typically two 8-bit EEPROMs to generate 16 control signals. Program the microcode ROMs with control sequences for each SAP-1 instruction (LDA, ADD, SUB, OUT, HLT, etc.). Wire the microcode address: combine IR opcode (upper 4 bits) with microstep counter to form address into microcode ROM. Connect microcode outputs to control signal lines (MI, RI, RO, AI, AO, BI, BO, EO, etc.). Test microcode execution: load an instruction into IR, step through microcode, verify control signals match expected sequence. Assessment: Students program microcode ROMs correctly for at least two instructions (e.g., LDA and ADD). They demonstrate step-by-step execution: load instruction, step through microcode, record control signals at each step, and verify they match the designed microcode sequence. They document the microcode address formation (IR opcode + microstep) and control signal generation.

- Weeks 16-18: Control Unit Integration. Objectives: Integrate the control unit with the data path to create a complete, automatically controlled CPU. Activities: Connect all control signals from microcode ROM to their destinations (MI to MAR load, RI to IR load, RO to memory output enable, etc.). Implement the fetch-decode-execute cycle: Fetch (PC → MAR → Memory → IR), Decode (IR opcode selects microcode), Execute (microcode generates control signals to perform operation). Add a Run/Halt switch to gate the clock. Add a single-step button for debugging (manual clock advance). Test complete instruction execution: load a simple program into memory (e.g., LDA 14h; ADD 15h; OUT; HLT), set PC to start address, enable Run, verify CPU executes instructions correctly. Debug any issues: use single-step mode, check control signals with logic probe/LEDs, verify timing. Assessment: Students demonstrate their CPU executing at least two complete instructions correctly (e.g., LDA loads value into Register A, ADD performs addition). They document the complete fetch-decode-execute cycle with timing diagrams or logic analyzer traces. They show the CPU can run a simple program (e.g., load two numbers, add them, output result) with correct results. This verifies the control unit is properly integrated and the CPU can execute instructions automatically.

### Term 2 Assessment

**Formative Assessments:**
- Weekly module testing and integration checkpoints
- Microcode design exercises
- Control signal sequencing practice
- Instruction execution debugging

**Summative Assessments:**
- **Week 10-12 Project**: Program Counter and Instruction Register - Students demonstrate PC counting and IR loading instructions, document instruction fetch sequence
- **Week 13-15 Project**: Microcode ROM System - Students program microcode ROMs, demonstrate step-by-step execution with control signal verification, document microcode address formation
- **Week 16-18 Project**: Control Unit Integration - Students demonstrate CPU executing complete instructions, document fetch-decode-execute cycle, show simple program execution with correct results

**Term Project:**
- Complete control unit demonstration: Students show CPU automatically executing instructions
- Written report explaining the fetch-decode-execute cycle and microcode operation
- Portfolio with microcode listings, timing diagrams, and execution traces
- Presentation demonstrating automatic CPU operation

## Term 3: SAP-1 Completion and Programming (Weeks 19-27)

- Weeks 19-21: SAP-1 Bring-up and Testing. Objectives: Complete system integration, perform initial bring-up, and systematically test and debug the complete SAP-1 CPU. Activities: Assemble the full SAP-1 on breadboards: clock, PC, MAR, RAM, IR, registers (A and B), ALU, output display (7-segment or LEDs), and control logic (microcode ROM). Perform initial bring-up procedures: verify power distribution, check all connections, test clock circuit. Use systematic testing approach: test each subsystem individually, then test integration. Use single-step mode and logic probe/LEDs on control lines to verify signals. Address common issues: timing problems with multiplexers (add capacitors or use 74HCT157 instead of 74LS157  $^{17}$ ), signal integrity (add  $0.1\mu \mathrm{F}$  decoupling capacitors near each IC's power pins  $^{18}$ ), miswired control signals. Start with a very simple program (e.g., load an immediate value and output it) to verify basic operation. Assessment: Students demonstrate their SAP-1 successfully completing initial bring-up. They document any issues found and fixes applied. They verify all subsystems are working: PC increments, IR loads, memory reads/writes, ALU operates, control signals generate correctly.

- Weeks 22-24: Machine Code Programming. Objectives: Learn the SAP-1 instruction set, program the CPU in machine code, and run complete programs. Activities: Study the SAP-1 instruction set: LDA (Load A from memory), ADD (Add memory to A), SUB (Subtract memory from A), OUT (Output A to display), HLT (Halt). Learn machine code format: 4-bit opcode + 4-bit operand (address). Use DIP switches or an Arduino-based EEPROM programmer to load programs into memory. Write and test simple programs: start with loading a value and outputting it, then progress to arithmetic programs (e.g., load two numbers, add them, output result). Learn to use the monitor/single-step mode for debugging programs. Test control flow if JMP or JZ instructions are implemented. Run the provided demo program that adds two numbers (e.g., LDA 14h; ADD 15h; OUT; HLT, which adds values at addresses 14 and 15  $^{13}$ ). Assessment: Students write and successfully run at least two programs: (1) an arithmetic program (e.g., addition or subtraction with correct result on output), and (2) a control flow program if available (e.g., using JMP or JZ instruction). They submit the machine code of their test programs and evidence of correct execution (output display or LEDs showing expected results).

- Weeks 25-27: System Completion and Documentation. Objectives: Complete final system testing, optimize performance, and document the complete SAP-1 system. Activities: Perform final system testing: run comprehensive test suite, verify all instructions work correctly, test at different clock speeds. Optimize performance: identify and fix any remaining timing issues, ensure reliable operation. Create complete system documentation: schematic diagrams, component list, instruction set reference, programming guide. Prepare system presentation: demonstrate working SAP-1, explain how it works, show example programs. Complete Year 3 portfolio: compile all work from Terms 1-3, include photos, schematics, test results, program listings. Assessment: Students produce complete system documentation including schematics, instruction set reference, and programming guide. They present their working SAP-1 system, demonstrating it running programs correctly. They submit Year 3 portfolio with all work documented. The "Year 3 complete" condition is that a student can sit down at their SAP-1, load a program, run it, and see correct behavior - demonstrating they have built a working 8-bit CPU and understand how it operates.

### Term 3 Assessment

**Formative Assessments:**
- Weekly testing and debugging exercises
- Program development practice
- System optimization exercises
- Documentation progress reviews

**Summative Assessments:**
- **Week 19-21 Project**: SAP-1 Bring-up and Testing - Students demonstrate successful bring-up, document issues and fixes, verify all subsystems working correctly
- **Week 22-24 Project**: Machine Code Programming - Students write and successfully run at least two programs (arithmetic and control flow), submit machine code and execution evidence
- **Week 25-27 Project**: System Completion and Documentation - Students produce complete system documentation, present working SAP-1, submit Year 3 portfolio

**Term Project:**
- Complete working SAP-1 computer demonstration
- Complete system documentation (schematic, instruction set, programming guide)
- Year 3 portfolio with all work from Terms 1-3
- Presentation demonstrating working CPU and explaining operation

Linking SAP-1 concepts to future work: Throughout Year 3, we note the limitations of SAP-1 and how later years will overcome them. For example, SAP-1's 4-bit address space (16 bytes of memory) severely limits programs  $^{6}$ . We discuss how one might expand the address space - indeed, some students may undertake an extra credit project to modify their SAP-1 for 256 bytes memory (by making the Program Counter and MAR 8-bit, and adding another RAM chip)  $^{19}$ ,  $^{20}$ . We explain that the 65C816 in Year 5 will directly support 24-bit addresses (16 MB of memory) to allow much larger programs  $^{1}$ . We also highlight how SAP-1 lacks a stack or subroutine capability - this will motivate adding a Stack Pointer in the 16-bit design, similar to how advanced SAP-1 improvements added a stack pointer and index register for subroutines and 16-bit indexing  $^{21}$ . The simple output (single 7-seg display) is noted as a stepping stone; in future years, we'll handle complex I/O like text and graphics display (the SAP-1's proposed VI signal for video input  $^{22}$  hints at this). This reflection prepares students to appreciate the enhancements that a more powerful architecture will bring.

**Year 3 Summary**: By the end of Year 3, students have built a complete working SAP-1 8-bit CPU from scratch. They understand every component: data path (ALU, registers, memory, buses), control unit (PC, IR, microcode), and how instructions are fetched, decoded, and executed. They can program their CPU in machine code and run complete programs. This deep understanding of CPU operation provides the foundation for working with commercial microprocessors in later years.

---

# Year 4 - SAP-1 Enhancements and 16-bit Transition (Age 16)

*Note: This was previously Year 2. Students now enter with a working SAP-1 from Year 3 and solid hardware foundations from Years 1-2.*

**Conceptual Reference**: **Malvino & Brown, Chapters 11-12 (SAP-2, SAP-3)** serve as **conceptual references** for understanding CPU enhancements. While we don't build SAP-2/SAP-3 (we transition to 65C816), these chapters explain the educational progression from simple (SAP-1) to enhanced (SAP-2) to advanced (SAP-3) features. Students learn about jumps, subroutines, stacks, and indirect addressing conceptually from the book, then implement these concepts using the 65C816's native instruction set. This provides the same educational progression while using modern, available hardware.

**Key Concept Mapping**:
- **SAP-2 Concepts** (Chapter 11): Jump instructions, call/return, register instructions, logic operations → Implemented via 65C816's JMP, JSR/RTS, register operations, AND/ORA/EOR
- **SAP-3 Concepts** (Chapter 12): Extended registers, indirect addressing, stack operations → Implemented via 65C816's 8/16-bit register modes, indirect addressing modes, stack instructions (PHA/PLA, etc.)

# Term 1: Completing the 16-bit Computer Hardware (Weeks 1-12)

- Weeks 1-4: Memory and Banking on 65C816. Objectives: Expand the prototype to utilize more memory and banks, reinforcing advanced addressing concepts. Activities: Increase RAM to 128KB or 512KB as budget allows, using banking. For example, if using two 32KB SRAMs, map one to bank $00 (for zero-page, stack, main memory) and one to bank $01, and demonstrate switching banks using the 65C816's data bank register or manual logic. Alternatively, use a single 512KB SRAM and implement bank switching via latch registers: e.g., have a latch on the higher address lines A16-A18 controlled by an I/O register (similar to how Commander X16 uses a bank register at $0000 for RAM bank) 37 38 . Teach how bank switching works by analogy to SAP-1's bank register proposal 39 - in the SAP-1 improvement notes, they suggested using an 8-bit register to page through larger RAM 40 41 . Now on the 65C816, we have built-in support via its 24-bit address, but we still might manually control chip selects if using a lot of memory. **Required Reading**: W65C816 Datasheet (memory banking section), 65C816 Programming Manual (addressing modes, native mode). **Architecture Note**: The system implements a Harvard-inspired architecture with separate program ROM and data RAM. Program code resides in ROM (bank $FF typically), while data and stack use RAM (banks $00-$01). This separation improves security and allows different access patterns for code vs data. Assessment: Students set up a test where they write distinct values to the same address in two different banks and verify that switching the bank register (or executing an instruction that loads data from another bank) retrieves the correct values. They provide a memory map showing which physical RAM corresponds to which address ranges or banks. This solidifies understanding of >64KB memory management.

- Weeks 5-8: Input/Output Subsystems. Objectives: Integrate essential I/O devices: text output, serial communication, and timers. Activities: Connect the VIA(s) and ACIA that were planned. For text output, initially use a simple solution: a serial terminal. Attach a WDC 65C51 ACIA (or a modern UART bridge) mapped to a known address (as per memory map, maybe $9F00)  $^{36}$ . Write a small assembly routine (in the monitor ROM) to send characters via the ACIA to a connected PC (through an FTDI or USB-serial adapter) – this allows the homebrew computer to output text to a terminal program. Also, use a VIA 6522 for a PS/2 keyboard interface: one approach is to use the VIA's shift register in synchronous mode to read PS/2 data or simply to connect a PS/2->UART converter. If that's too complex, skip keyboard for now and plan to use PC serial for input. Additionally, use VIA's parallel ports to interface simple outputs: e.g., an LED array or a  $2 \times 16$  LCD character display (Michael Kamprath's project added a  $20 \times 4$  LCD to enhance output capability  $^{42}$ , and so will we as an interim output before graphics). Have students code a routine that writes a message to the character LCD or blinks an LED via the VIA port, to verify I/O operation. Cover timers: the VIA's timers can be used to generate periodic interrupts – set up a timer to trigger an interrupt, although perhaps don't enable interrupts yet until the OS stage. Assessment: The 65C816 system should now be able to interact: demonstrate by having it print "HELLO" over serial or display it on the LCD. Each team provides a log (screenshot) of their computer's output in a terminal or photo of LCD. They also fill out an I/O map: listing each device (ACIA, VIA1, VIA2, any others) and the addresses used for their registers, confirming they understand how the CPU communicates with peripherals via memory-mapped I/O.

- Weeks 9-12: Graphics and Sound Options – Research and Prototype. Objectives: Explore methods to add video and audio to the system in preparation for the final console, deciding on which to implement. Activities: This is partly research/theory and partly small prototyping. Break students into two focus groups: one for Video output, one for Audio output. Video group: Investigate options for generating a display. Possibilities include using an older video display controller (e.g. Yamaha V9938/V9958 as used in MSX computers, which could be interfaced to 65C816 bus – an example homebrew project used 65C816 + V9958 for graphics  $^{43}$ ), or using a modern microcontroller as a video co-processor. Note: VERA FPGA is not used as it is a black box (FPGA-based) that limits educational value, despite being an excellent solution used in other projects. Students consider trade-offs: A TMS9918 chip offers tile graphics and composite video but low resolution; an FPGA like VERA or a Propeller MCU can give high resolution and HDMI but is complex; a simpler approach is an  $8 \times 8$  LED matrix or small SPI TFT. Given our offline-first constraint, likely we choose something like VGA text mode generation using discrete logic or a microcontroller. As a hands-on task, this group might build a small DAC (resistor ladder) and use a

counter to generate a VGA grayscale ramp or similar, just to see the challenge of timing. Audio group: Research the YM2149F (essentially an AY-3-8910 sound chip) – a 3-voice PSG widely used in 80s computers, and the SAM2695 MIDI synth chip. They learn how such chips are interfaced (typically via an 8-bit data bus and some address or register select lines). The group can breadboard a simple sound experiment: e.g., use a 555 timer or microcontroller PWM to generate tones and drive a small speaker, then compare with what a PSG chip could do (if available, possibly wire up a YM2149F on a breadboard and send it writes to produce tones). By end of this term, the class should decide on a video solution and an audio solution to integrate in Year 6. Assessment: Each focus group produces a short proposal/feasibility report. The video group might cite that others have successfully attached the TMS9918 to homebrew CPUs and outline the steps to do so, or propose using a ready-made module (e.g., a Raspberry Pi Pico running VGA or HDMI PIO code). The audio group will outline how to integrate the YM2149F (e.g., needs a latch for address/data, and audio output filtering) or SAM2695 (MIDI commands via serial). They also list parts needed and estimated cost. This research is presented to the whole class for a decision. (In practice, to keep things buildable on PCB/breadboard, we might favor YM2149 for sound and either a simple tile graphics VDC or a microcontroller for video. The outcome will influence the Year 6 plan.)

### Term 1 Assessment

**Formative Assessments:**
- Weekly memory and banking exercises
- I/O interface design exercises
- Graphics/audio research progress checks

**Summative Assessments:**
- **Week 1-4 Project**: Memory and Banking - Students set up bank switching tests, verify correct values in different banks, and provide memory maps showing address ranges
- **Week 5-8 Project**: I/O Subsystems - Students demonstrate text output (serial or LCD), provide I/O maps listing devices and addresses, and verify I/O operation
- **Week 9-12 Project**: Graphics and Sound Research - Students produce feasibility reports, outline integration steps, list parts and costs, and present proposals to class

**Term Project:**
- Complete 65C816 system with memory, banking, and I/O
- Written report on system capabilities
- I/O map and memory map documentation
- Graphics/audio decision documentation

# Term 2: Software Stack Development (Weeks 13-24)

- Weeks 13-16: Monitor Program and Machine Code Monitor. Objectives: Develop a basic monitor (bootloader) for the 65C816 machine that allows interaction without a development PC. Activities: Using assembly (taught concurrently in classroom sessions), students collectively write a simple monitor program to reside in the system ROM. **Language Strategy**: Assembly is used here for system-level programming (monitor, bootloader, low-level I/O). This provides essential understanding of how the CPU operates and how high-level languages interface with hardware. Most application programming will use Pascal, but students need assembly for system programming. **Conceptual Reference**: Malvino & Brown, Chapter 11 (SAP-2) - Section 11-5 (Jump and Call Instructions) provides conceptual understanding of program flow control, jumps, and subroutines. While SAP-2 uses JMP/CALL/RET, the 65C816 uses JMP/JSR/RTS with similar concepts. Students understand the educational progression: SAP-1 had no jumps → SAP-2 added jumps and subroutines → 65C816 provides these natively. **Required Reading**: **Malvino & Brown, Chapter 14** (Programming & Languages) - General assembly language concepts, instruction categories, programming patterns. While the book uses different CPUs for examples, the concepts (instruction types, addressing modes, program structure) apply to all assembly languages including 65C816. Features of the monitor: upon reset, print a greeting over serial (or display), then accept hex commands to examine memory, modify memory, and execute programs. This is similar to classic monitors (like Wozmon for Apple 1). Because we assumed offline environment, the monitor is crucial - it lets students enter small programs directly if needed and test them. Students implement commands like "M" (dump memory from address), "E" (edit memory), "G" (goto/run address), etc. The "G" command uses jump instructions (JMP or JSR on 65C816) - students understand this conceptually from SAP-2's jump instructions. Also include a simple hex file loader: since we have an SD card interface planned (Term 3), the monitor could load a program from SD card if present. At minimum, allow loading via serial (e.g., receive Intel HEX format over serial to load programs). This is ambitious but extremely educational (they learn about serial protocols, parsing, etc.). **Required Reading**: 65C816 Programming Manual (instruction set, addressing modes), CC65 documentation (ca65 assembler syntax), Malvino & Brown Chapter 11-5 (Jump and Call Instructions) for conceptual understanding, **Malvino & Brown Chapter 14** (Programming & Languages) for general assembly language concepts. Assessment: The monitor is tested by using it to perform a simple task: e.g., use the monitor to change a RAM value and then verify it changed, or load a small program (provided as a list of addresses/values) and run it. Each student writes a short reflection on the experience of using their own computer's ROM monitor vs a PC - understanding that their machine is now self-hosting to a degree. The monitor code listing is reviewed to ensure good use of assembly and proper function of stack and interrupts (if any used).

- Weeks 17-20: Assembler and Toolchain (cross-development). Objectives: Introduce the use of an assembler for the 65C816 and plan transitioning from cross-assembling on PC to possibly assembling on the device. Activities: At first, students use a cross-assembler (like the ACME or ca65, available offline) on a PC to write assembly programs for their machine. They write a few sample programs: e.g., a program to print "Hello World" via the monitor's print routine, or a program to draw a pattern (if graphics hardware exists). They learn about assembler directives, addressing modes of 65816, and how to link with the monitor/firmware routines. **Language Strategy**: Assembly is taught here for understanding low-level operations and system programming. Students write small assembly programs to understand how instructions map to machine code and how the CPU executes programs. This foundation is essential before moving to Pascal, as it helps students understand how high-level code compiles to assembly and then to machine code. However, the majority of application development will use Pascal for productivity and maintainability. **Conceptual Reference**: **Malvino & Brown, Chapters 16-23** (Instruction Sets) - These chapters cover instruction categories (data transfer, arithmetic, logic, branches, etc.) using different CPUs (6502, 6800, 8080/8085, 8086/8088) as examples. While the specific instructions differ, the **categories and concepts** are universal. **Gap Bridging**: **65C816 Concept Bridging Guide** (see `curriculum/Year4/Term2/65C816_CONCEPT_BRIDGING.md`) provides comprehensive mapping of book examples to 65C816 equivalents. Students should:
  1. Read the book chapters for **conceptual understanding** of instruction categories (what are data transfer instructions, arithmetic instructions, branch instructions, etc.)
  2. Use the **bridging guide** to see how book examples (from different CPUs) map to 65C816 equivalents
  3. Apply these concepts to **65C816-specific instructions** using the 65C816 instruction set reference (see `docs/65C816_INSTRUCTION_SET_REFERENCE.md`)
  4. Practice **translation exercises** (convert book examples to 65C816 code)
  5. Understand that all CPUs have similar instruction categories, just with different mnemonics and capabilities

Then discuss what it would take to have an assembler on the device: perhaps too heavy for 65C816 given memory constraints, but at least conceptually. As an exercise in understanding compilers, the class can examine the simple assembler written by James Bates for his 8-bit TTL CPU 47 - it was written in C with lex/yacc. Students could modify or write a Python script to assemble a very small set of instructions on their own. However, since our aim is to move to Pascal, we do not spend too long here - just enough that students know how assembly translates to machine code (they could manually assemble a few instructions and verify in memory). **Required Reading**: CC65 Toolchain Documentation (ca65 assembler), 65C816 Assembly Language Guide, **Malvino & Brown Chapters 16-23** (Instruction Sets) for conceptual understanding of instruction categories, **65C816 Concept Bridging Guide** (see `curriculum/Year4/Term2/65C816_CONCEPT_BRIDGING.md`) for mapping book examples to 65C816, **65C816 Instruction Set Reference** (see `docs/65C816_INSTRUCTION_SET_REFERENCE.md`) for 65C816-specific instructions. Assessment: Students assemble and run an example assembly program on their computer. They turn in the source, the assembled machine code, and the output or result

of the program on their device. For instance, an assembly program to compute a mathematical series and output the results. This confirms they can develop software for the custom hardware - a key capability before tackling the high-level language.

- Weeks 21-24: Pascal Runtime and Language Prep. Objectives: Lay the groundwork for the SuperPascal language on the system by determining runtime needs and writing low-level support routines. Activities: Introduce the subset of Pascal we'll implement (based on Per Brinch Hansen's SuperPascal – a concise Pascal with some extensions [48]). **Language Strategy**: Pascal is chosen as the primary high-level language due to its educational value, clear syntax, and easier access compared to other languages. Students will write most application code in Pascal, using assembly only for system-level routines (runtime library, I/O drivers, interrupt handlers). This approach provides productivity for complex programs while maintaining understanding of low-level operations. Explain the runtime features needed: memory management (we'll keep it simple: static or preallocated structures, maybe no heap initially), I/O (Pascal write/writeFrom mapping to our device output), and math library (for integer arithmetic, and perhaps fixed-point for any fractional math or trig). Students implement some runtime library routines in assembly, to be called from Pascal programs. For example, implement WriteChar and WriteString routines that the Pascal System unit can use to output text (these will interface with the monitor's printing or directly to ACIA). Implement basic math like 16-bit multiply or divide if not present in hardware (65816 doesn't have multiply, so we may provide a routine). For trig, decide on using lookup tables: e.g., prepare a table of  $\sin (\theta)$  scaled values in a ROM or as data, for a possible graphics demo later. Also, define the ABI (Application Binary Interface) for calling between Pascal and assembly. For instance, decide that our Pascal compiler will use a stack-based calling convention (perhaps similar to standard C/Pascal: parameters pushed right-to-left, etc.), or possibly a simpler model (maybe use direct jump with static workspace as Wirth's Pascal P-code did, but likely we do actual machine code generation). Write a small demo of calling an assembly routine from a high-level perspective: e.g., simulate what happens when Pascal calls a procedure – how the CPU uses the stack pointer and what prologue/epilogue are needed. **Required Reading**: SuperPascal Language Specification, Compiler Design References (for understanding code generation). Assessment: Students document the agreed calling convention (register usage, how parameters are passed) and provide a couple of tiny assembly routines with proper stack frame handling. These will be used by the compiler's code generator. For runtime, they might test one routine – for example, call the assembly WriteChar from a simple main program (written in assembly as a stand-in for Pascal main) to ensure it prints a character correctly. By clarifying and testing the runtime pieces now, we reduce errors when integrating the compiler output in Year 6. The assessment ensures that the class has a common understanding of how high-level language calls will work on their architecture, and that some core library functions are ready.

### Term 2 Assessment

**Formative Assessments:**
- Weekly software development checkpoints
- Monitor command testing
- Assembly programming exercises
- Runtime design discussions

**Summative Assessments:**
- **Week 13-16 Project**: Monitor Program - Students test monitor functionality (memory examination, editing, program execution), write reflections on using their own computer's ROM monitor, and submit monitor code for review
- **Week 17-20 Project**: Assembler and Toolchain - Students assemble and run example assembly programs, submit source code, assembled machine code, and program output/results
- **Week 21-24 Project**: Pascal Runtime Preparation - Students document calling conventions, provide assembly routines with proper stack frames, test runtime routines, and demonstrate calling assembly from high-level perspective

**Term Project:**
- Working software development environment demonstration
- Written report on software stack development
- Code portfolio with monitor, assembler programs, and runtime routines
- Documentation of ABI and calling conventions

# Year 5 - System Integration and Expansion (Age 17)

*Note: This was previously Year 3. Students now enter with enhanced 8-bit systems from Year 4 and are ready for 16-bit architecture.*

# Term 1: PCB Design and Assembly (Weeks 1-12)

- Weeks 1-5: Finalizing PCB Schematics and Layout. Objectives: Turn the breadboard 65C816 system (from Year 5) into PCB designs, optimizing for reliability and usability. Activities: Students, familiar with schematic capture from Year 5, now finalize schematics for the CPU Board and any Peripheral Boards. Likely, we'll have a main board containing CPU, memory, and core I/O (VIA, ACIA), and possibly separate boards or modules for video and sound (to reduce complexity and allow optional installs). Key tasks: ensure power distribution is robust in the design - add a proper 5 V regulator (with input from a DC jack or USB), a power switch, and plenty of decoupling capacitors near each IC (both  $0.1\mu \mathrm{F}$  ceramics and a few larger electrolytics for bulk smoothing)  $^{18}$ . Design a reset circuit using a supervisor IC or at least an RC + Schmitt trigger to guarantee clean reset on power-up. Provide connectors: e.g., a slot for the SD card module, a dual-row header for expansion (exposing the address/data bus like WDC's XBus header  $^{49}$  so future expansions or logic analyzer connections can be made), PS/2 or USB ports for keyboard/controllers, and RCA or HDMI out depending on video choice. The schematic should incorporate the video chip or microcontroller chosen (e.g., if using the V9958 VDP, include its connections and VRAM; if using a microcontroller for video, include a connector or socket for it). Similarly for sound (YM2149F chip plus an audio jack and amplifier if needed). Once schematics are peer-reviewed, students move to PCB layout. They identify which subsystems might

need closer placement or specific routing (e.g., data bus traces should be short and ideally buffered if leaving the main board; the clock circuit should be near the CPU; if using analog video or audio, isolate those sections, provide ground fills or planes to reduce noise). They will likely produce multiple smaller PCBs rather than one huge one, for manageability: e.g., a CPU+memory board, a video board, an audio board, and a backplane or connector mechanism to join them. Ensure to add test points and headers: put test pads for logic analyzer on the bus lines and critical signals (e.g.,  $\phi 2$  clock, R/W, IRQ lines) so that even when built, the teacher and students can hook analyzers to debug. Perhaps include a JTAG header if any programmable logic or microcontroller is present (for reprogramming firmware on, say, a video microcontroller). Students then generate Gerber files and prepare to send out to PCB fabrication (we assume using PCBWay or similar, with a couple of weeks lead time, so they must finish by mid-term). Assessment: The final schematic and layout files are checked by a mentor/teacher for errors. Assessment is a design review: each team explains the reasoning behind their layout (why certain chips are placed together, how they handled ground routing, etc.). A checklist is used: e.g., "Every IC has a decoupling cap? Power traces wide enough? Any long parallel runs that could cause crosstalk? Are all connectors labeled and keyed to avoid reverse connection?" Only after passing this review are boards ordered. This mimics a professional PCB design cycle and enforces best practices in hardware design.

- Weeks 6-9: PCB Assembly and Unit Testing. Objectives: Solder components onto the manufactured PCBs and verify each module works standalone before integration. Activities: The class will receive the fabricated PCBs (hopefully by week 6 or 7). They then proceed to populate them. Teach techniques for soldering (through-hole is likely given DIP ICs like 65C816, but some chips like memory might be DIP or SOIC – if so, teach careful SMD soldering). Emphasize ESD precautions: wear wrist straps, work on ESD mats when handling sensitive CMOS chips (like the CPU or memory) – one errant static zap can kill chips, which are limited in supply. Once a board is assembled, perform continuity tests and smoke tests: check with a multimeter that power and ground are correctly connected and there are no shorts (measure resistance between 5V and GND to ensure no short). Apply power first with no chips socketed to check the regulator output is correct  $5.0\mathrm{~V}$ , etc. Then insert chips and power up, checking if any chip overheats (indicative of short or wrong orientation). After that, test each subsystem separately (unit testing approach): for example, on the CPU board, before even running the CPU, test that the reset circuit outputs a clean reset pulse (by toggling power and using oscilloscope on RESET pin). Test the clock generator (scope on  $\phi2$  pin to see stable clock). Test address decoding by writing a simple test firmware on ROM that lights an LED on a VIA port; then power the board with that ROM and see if the LED lights – this tests that the CPU, ROM, and VIA are basically working in concert. Meanwhile, test peripheral boards: e.g., on the video board (if using a known chip like V9958), do a minimal test by writing its registers via the bus (this might require piggybacking on the CPU board for signals or using a microcontroller to simulate bus writes in a test jig). Similarly for the sound board, perhaps manually toggle its registers to see if it emits a tone (or use an Arduino as a test harness before connecting to CPU). Document these tests as validation protocols to ensure each part meets its “definition of done” before system integration. Assessment: Students maintain an assembly log: for each board, record the tests performed and results. For example, “Main Board Test 1: Clock output 1.8432 MHz verified on pin  $\phi2$  50 . Test 2: Reset line goes high 100 ms after power – verified. Test 3: Executed test ROM, observed activity on address lines and LED output on VIA – PASS.” Any issues (like a missing trace or wrong wiring in PCB) are noted and fixed by blue-wires if needed. The instructor checks these logs and may spot-check by having a student demonstrate a test (this ensures no board is integrated untested). Achieving a fully populated and individually tested set of boards is a huge milestone by end of Term 1.

- Weeks 10-12: System Integration on PCB. Objectives: Combine the boards into the final system and verify the full computer works as intended. Activities: Mount the boards on a common backplane or

connect via ribbon cables as designed. This forms the complete console/computer. Now execute an integration test plan: essentially a repeat of Year 5's final tests but on the new hardware. Power on the full system and run the monitor program in ROM. Check that the serial output works from ROM (e.g., the sign-on message appears on terminal). Test memory by running the memory diagnostics (the monitor likely includes a memory test routine or one can be loaded via serial). Test interrupts by generating one (if we have, say, a timer interrupt, see if the CPU jumps to the interrupt vector routine). Crucially, test the new features: video and audio. For video: initialize the video chip (via code) and attempt to put something on screen - e.g., a test pattern or "Hello" text. For audio: send a few tone commands to the PSG to produce audible notes (use a small speaker or headphone to listen). A logic analyzer can be used here on the bus to confirm that when the CPU writes to the video or sound addresses, the correct signals toggle (for example, see the chip select for the YM2149F go low and data lines change when sending it a register write). At this integration stage, expect some issues - e.g., timing differences on PCB vs breadboard, need to adjust wait states or clock speed. Perhaps the 65C816 can be clocked faster on PCB (maybe up to 4-8 MHz safely) now that signals are cleaner, but initially, run at the breadboard speed until all is verified. Once stable, you may increase the clock and see if everything still works; if not, identify if any timing fixes needed (like adding bus wait states or using faster logic chips). Also, incorporate the SD card interface now if not already: test that the system can detect and read from an SD card (perhaps using a simple SPI routine via a VIA or a dedicated SPI interface if included). Use a pre-loaded card with a known file and see if the monitor can read a byte from it. Assessment: The final system must pass a functional test suite: (1) Boot Test - does the monitor greet and accept commands? (2) Memory Test - can read/write various addresses correctly (no bus errors or data corruption across the 64KB boundary, etc.). (3) Peripheral Test - keyboard input (or serial input) can be accepted, output devices (serial, LCD, or video) display characters properly, sound can be made. (4) Performance Test - if possible, run at target speed (e.g., 4 MHz) and ensure the machine doesn't crash (this might involve running a simple loop for a while). Each student group produces a "System Acceptance Test" report with results for each of these. Any failing tests must be resolved (with help of instructors/mentors) and documented. By the end of Term 1, the class has an assembled 16-bit computer-conSOLE that is theirs, passing core diagnostics. From now on, focus shifts to using this machine for interesting projects and high-level programming (the hardware foundation is complete).

### Term 1 Assessment

**Formative Assessments:**
- Weekly schematic and layout reviews
- PCB design best practices exercises
- Soldering technique practice
- Unit testing protocol development

**Summative Assessments:**
- **Week 1-5 Project**: PCB Schematic and Layout - Students produce final schematics and layouts, pass design review explaining layout reasoning, and complete checklist verification before board ordering
- **Week 6-9 Project**: PCB Assembly and Unit Testing - Students maintain assembly logs documenting all tests performed, demonstrate unit tests to instructor, and achieve fully populated and tested boards
- **Week 10-12 Project**: System Integration - Students produce "System Acceptance Test" reports with results for boot, memory, peripheral, and performance tests, resolve any failing tests, and demonstrate complete working system

**Term Project:**
- Complete assembled 16-bit computer-console on PCB
- System acceptance test report
- Assembly and testing documentation
- Presentation of final hardware system

# Term 2: System Programming and Integration (Weeks 13-24)

**Note**: Year 6 Term 2 focuses on **system-level programming** that directly exercises and supports the hardware project. Compiler development (SuperPascal) runs in parallel as a separate project. The focus here is on system software (monitor, boot loader, device drivers, system services) that makes the hardware functional and usable.

- **Weeks 13-16: Enhanced Monitor and Boot Loader**. Objectives: Extend the Year 5 basic monitor with advanced debugging features and implement a boot loader for loading programs from SD card storage. Activities: Students extend the basic monitor program from Year 5 with advanced features: breakpoints (stop execution at specific address by replacing instruction with BRK), watchpoints (monitor memory locations and stop when values change), disassembly (convert machine code to assembly mnemonics for debugging), step-by-step execution, system information commands (memory map display, device status), and SD card loading capability. The enhanced monitor provides essential debugging tools for hardware testing and program development. Students then implement a boot loader that interfaces with SD card hardware via SPI, initializes SD cards, reads files (binary or Intel HEX format), loads programs into memory, verifies program integrity with checksums, and executes loaded programs. The boot loader enables practical program development workflow - students can develop programs on PC, transfer to SD card, and load/execute on the hardware without reprogramming ROM. Assessment: Students extend monitor with 3+ new features, demonstrate SD card loading, show breakpoint and disassembly working, implement boot loader that successfully loads and executes programs from SD card, and create user documentation for monitor and boot loader commands.

- **Weeks 17-20: Device Drivers**. Objectives: Write device drivers for video, audio, input, and storage devices, providing high-level APIs for applications. Activities: Students write device drivers that interface directly with hardware peripherals. **Week 17 (Video Driver)**: Initialize video chip (TMS9918/V9938/V9958 or microcontroller solution), set graphics modes, implement graphics primitives (pixel operations, line drawing using Bresenham algorithm, rectangle drawing), sprite operations (create, move, show/hide sprites), and text output (character rendering, string drawing). Note: VERA FPGA is not used as it is a black box that limits educational value. **Week 18 (Audio Driver)**: Initialize audio chip (YM2149F PSG or SAM2695 MIDI synthesizer), implement tone generation (frequency calculation, volume control, multi-channel support), music playback (music data format, sequencer engine, tempo control), and sound effects (beep, click, explosion, swoosh). **Week 19 (Input Drivers)**: Implement PS/2 keyboard driver (PS/2 protocol, scan code reception and translation, key state tracking, key buffering), gamepad driver (interface setup, button/direction reading, input processing), and unified input API (key read, key state checking, input event system). **Week 20 (SD Card Driver)**: Implement SD card initialization (SPI protocol, initialization sequence with CMD0/CMD8/ACMD41), block reading/writing (CMD17/CMD24 for single blocks, CMD18/CMD25 for multi-block), and file system interface (basic file operations, directory operations, simplified FAT or fixed-location file system). Each driver follows layered architecture: hardware layer (direct register access), driver layer (device initialization and control), and API layer (high-level interface for applications). Drivers include error handling, initialization/cleanup routines, and interrupt support where applicable. Assessment: Students implement at least one complete device driver (video, audio, or input), demonstrate driver initialization and usage, show driver being used by application, create driver API documentation, and test driver error handling.

- **Weeks 21-24: System Services and Integration**. Objectives: Design and implement system services API, implement interrupt handlers, implement memory management, and integrate all system components into a complete, functional system. Activities: **Weeks 21-22 (System Services API)**: Students design system services architecture with service categories (file system services, I/O services, memory services, system information services, program management services). They implement service call mechanism (software interrupts or function calls, parameter passing via registers/stack, return values, error codes). File system services use SD card driver for storage operations. I/O services provide unified interface to console (print, read), graphics (mode setting, drawing primitives), and sound (tone, music, sound effects). Memory services implement heap allocator (first-fit or best-fit algorithm, free list management, block coalescing) and memory map tracking. System information services provide system status, memory info, and device status. Program management services use boot loader for program loading and execution. Services are integrated with monitor (service commands) and boot loader (service usage). **Week 23 (Interrupt Handlers)**: Students set up interrupt vector table, implement timer interrupts (VIA timer configuration, system clock updates, task scheduling support), implement I/O interrupts (keyboard interrupts for key processing, serial interrupts for data reception/transmission), and implement interrupt management (enable/disable, priority handling, interrupt status). **Week 24 (System Integration)**: Students implement complete boot sequence (hardware reset, vector table setup, hardware initialization, driver initialization, service initialization, monitor start), integrate all components (monitor, boot loader, drivers, services, interrupt handlers), implement memory management (heap allocator, memory map, memory protection), perform comprehensive system testing (unit tests, integration tests, stress tests, performance tests), and create complete system documentation (user manual, technical manual, API reference, developer guide). The "curriculum complete" condition is that a student can sit down at the built computer, reset it, interact with the enhanced monitor, load a program from SD card via boot loader, execute the program, and see correct behavior with graphics, sound, and input working. Assessment: Students design and implement system services API, demonstrate services working, implement interrupt handlers, integrate all system components, test complete system, create system documentation, and demonstrate "curriculum complete" condition. Each student writes a reflection on the most challenging and most rewarding parts of the 6-year journey.

(Thus, by the end of Year 6, the class has a fully realized 16-bit computer system with video and sound – a mini retro-console – with complete system software stack including enhanced monitor, boot loader, device drivers, system services, and interrupt handlers. They have traversed the journey from simple logic gates (Year 1) to building and programming a complete computer system (Year 6), understanding every layer from hardware wiring to system software. The system is functional, documented, and ready for application development using the SuperPascal compiler developed in parallel.)

### Term 2 Assessment

**Formative Assessments:**
- Weekly system programming progress checks
- Driver development exercises
- Service design discussions
- Integration testing reviews
- Documentation progress reviews

**Summative Assessments:**
- **Week 13-16 Project**: Enhanced Monitor and Boot Loader - Students extend monitor with 3+ new features (breakpoints, disassembly, system info), demonstrate SD card loading, implement boot loader that loads and executes programs from SD card, and create user documentation
- **Week 17-20 Project**: Device Drivers - Students implement at least one complete device driver (video, audio, or input), demonstrate driver initialization and usage, show driver being used by application, create driver API documentation, and test error handling
- **Week 21-24 Project**: System Services and Integration - Students design and implement system services API, demonstrate services working, implement interrupt handlers, integrate all system components, test complete system, create system documentation, and demonstrate "curriculum complete" condition (boot, interact with monitor, load program from SD card, execute program, see correct behavior)

**Term Project:**
- Complete system software stack (enhanced monitor, boot loader, device drivers, system services, interrupt handlers)
- Complete documentation set (user manual, technical manual, API reference, developer guide)
- System integration demonstration
- Final reflection on 6-year journey
- Demonstration of complete system functionality

## Term 3: Advanced Software and A-Level Preparation (Weeks 25-36)

**Outcome**: Students develop PascalOS operating system features, create advanced Pascal programs, and complete A-Level project work.

- Weeks 25-28: PascalOS Development. Objectives: Extend the monitor to a full operating system (PascalOS), implement file system support, add program management, and create system services API. Activities: Evolve the monitor into PascalOS: while the monitor provides debugging capabilities, PascalOS provides system services. Implement basic file system support: create directory structure, implement file operations (create, read, write, delete), manage file metadata, implement storage management. Use EEPROM or external storage (SD card) for file storage, implement simple file system structure with file allocation table and directory entries. Add program management: load programs from storage, relocate programs if needed, set up execution environment, start program execution. Implement program services: program listing, program execution, program termination, resource cleanup. Create system services API: define service categories (file operations, I/O operations, memory management, system information, process control), design service call mechanism with parameter passing and return values, implement error handling. Implement basic cooperative multitasking: allow programs to yield control voluntarily, implement simple task switching, manage task state, enable round-robin execution of multiple tasks. Assessment: Students demonstrate PascalOS with working file system (can create, read, write, delete files). They show program management (can load and execute programs from storage). They implement at least one system service and demonstrate its use. They document the system services API.

- Weeks 29-32: Advanced Pascal Programming. Objectives: Use advanced Pascal features, create graphics and sound programs, develop games, and build complete applications. Activities: Master advanced Pascal language features: records and structures for complex data, pointers and dynamic memory (if supported), advanced procedures and functions, units and modules for code organization, object-oriented concepts (if supported). Learn programming techniques: implement data structures (lists, trees, queues), use algorithms (sorting, searching), organize code effectively, implement error handling. Create graphics programs: manipulate pixels, implement drawing primitives (lines, circles, rectangles), work with sprites and bitmaps, create animations, build graphics libraries. Use graphics hardware (if available) or implement software rendering, design graphics API, optimize performance. Create sound programs: generate sounds, compose music, create sound effects, implement audio playback, build sound libraries. Use sound hardware (if available) or implement software synthesis, design sound API, handle timing and synchronization. Develop games: implement game loop, handle input, implement collision detection, manage game state, design game architecture. Integrate graphics and sound, implement user interaction, code game logic. Build complete applications: combine multiple features, create user interfaces, implement data persistence, handle errors gracefully. Assessment: Students create at least one advanced Pascal program demonstrating graphics or sound capabilities. They develop a simple game or interactive application. They submit source code with clear structure and comments. They demonstrate programs running on actual hardware.

- Weeks 33-36: A-Level Project Development. Objectives: Complete A-Level project, document complete system, prepare project presentation, and demonstrate system capabilities. Activities: Complete A-Level project: ensure working system demonstration, create complete documentation, compile code portfolio, write project report, prepare presentation. Create system documentation: document system architecture with diagrams, create hardware documentation (schematics, component lists), create software documentation (code structure, APIs, algorithms), write user manual (how to use the system), write developer guide (how to extend the system). Follow documentation standards: clear structure, complete coverage, professional presentation, include diagrams and illustrations, provide code examples. Write project report with proper structure: introduction (project overview, objectives), analysis (requirements, constraints), design (system design, component design), implementation (how it was built, challenges faced), testing (test procedures, results), evaluation (what worked, what didn't, improvements), conclusion (summary, future work). Ensure report quality: clear writing, technical accuracy, comprehensive coverage, critical evaluation, reflection on learning. Create portfolio: system overview, key achievements, code samples, documentation excerpts, demonstration videos/photos. Organize portfolio professionally: logical structure, clear presentation, highlight best work. Prepare project presentation: create presentation materials, practice delivery, prepare demonstrations, anticipate questions. Demonstrate "curriculum complete" condition: student can sit down at built computer, reset it, interact with monitor/PascalOS, load a program (from SD or serial), run it, and see correct behavior. Assessment: Students produce complete A-Level project with all required components. They submit project report meeting A-Level standards. They present project demonstrating system capabilities. They demonstrate "curriculum complete" condition successfully. They reflect on the 6-year journey, identifying most challenging and most rewarding aspects.

### Term 3 Assessment

**Formative Assessments:**
- Weekly development checkpoints
- PascalOS feature testing
- Advanced program development progress
- Documentation progress reviews

**Summative Assessments:**
- **Week 25-28 Project**: PascalOS Development - Students demonstrate PascalOS with working file system and program management, implement system services, document API
- **Week 29-32 Project**: Advanced Pascal Programming - Students create advanced programs (graphics/sound/games), submit source code, demonstrate programs running on hardware
- **Week 33-36 Project**: A-Level Project Development - Students produce complete A-Level project, submit project report, present project, demonstrate "curriculum complete" condition

**Term Project:**
- Complete A-Level project with all components
- Complete system documentation (architecture, hardware, software, user manual, developer guide)
- Project report meeting A-Level standards
- Project presentation with demonstrations
- Portfolio of complete 6-year journey
- Reflection on learning and achievements

**Year 5 Summary**: By the end of Year 5, students have built a complete 16-bit computer system on PCB with working SuperPascal compiler, PascalOS operating system, and advanced software capabilities. They have created graphics and sound programs, developed games, and completed their A-Level project. They understand every layer of the system from hardware wiring to compiler code generation, and can demonstrate a fully functional computer system they built from scratch.

---

# Year 6 - Bringing It All Together: The 65C816 Console and SuperPascal (Age 18)

*Note: This was previously Year 4. Students now enter with a working 16-bit system from Year 5 and are ready for final integration, PCB design, and software stack completion.*

# Hardware Roadmap: Breadboard to PCB

To manage the hardware complexity, the build is structured in stages, each introducing new components and design techniques. At each stage, students assemble a functional subsystem, test it thoroughly, and often use it as a stepping stone for the next stage. Below is the roadmap of stages from initial breadboard experiments to final PCB implementation:

# Stage 0: Foundations - Power, Clock, and Lab Setup

Components: 5 V regulated power supply (could be a benchtop supply or a 5 V 2A adapter with an LM7805 or buck converter for stable 5V), breadboards, jumper wires, multimeter, basic oscilloscope or logic probe, assorted resistors and capacitors (for debouncing and decoupling), 555 timer IC, LEDs (with built-in resistors or external resistors)  $③$ , switches, push buttons.

Schematic Blocks: A simple power distribution bus on the breadboard with a power switch and LED power indicator; a 555 timer astable circuit generating a clock pulse (with potentiometer for frequency control, and a switch to toggle between manual clock and auto)  $^{52}$ ; an RC debouncer for input buttons (or Schmitt-trigger buffer like 74HC14 if desired).

IC Families: Not many ICs here besides 555 and maybe linear regulators. Use CMOS 555 timers (for 5 V operation). Level of logic not critical yet. Begin to acquire 74HC-series parts for later (HC or HCT

recommended moving forward for compatibility with CMOS CPU signals).

Clocking Strategy: At this stage, clock can be a 555 generating from  $\sim 1$  Hz to a few kHz, plus a push-button for single-step pulses. Ensure the clock output is a clean square (maybe add a Schmitt trigger buffer to sharpen if needed, or use a TTL oscillator module later for faster speeds).

Test Strategy: Verify the power rails at multiple points on the breadboard (5.00 V nominal). Check that when the switch is off, no standby leakage to chips. For the clock, visualize with an LED (it should blink, varying speed with pot). Use an oscilloscope to ensure the waveform goes from 0 to 5 V fully (no intermediate levels). Also, test the reset circuit: e.g., if using an RC reset, see that on power-up RESET stays low for a brief moment then goes high. Confirm debounced switch outputs by observing no spurious oscillations on an LED or scope when pressing.

# Stage 1: Digital Logic Gates and Flip-Flops (Building Basic Understanding)

Components: 74HC00 (quad NAND), 74HC32 (quad OR), 74HC04 (inverters), 74HC08 (AND), 74HC86 (XOR) for logic; 74HC74 (dual D flip-flop), 74HC161/163 (4-bit binary counter), 74HC138 (3-to-8 decoder) as representative sequential logic; Resistors for LED outputs; 7-segment display + 74HC47/74LS47 BCD-to-7seg driver (optional, for visualizing 4-bit outputs in decimal).

Schematic Blocks: Typical arrangements like a full adder built from gates, a 2-bit or 4-bit latch using D flip-flops, a ripple counter to cycle through values. Essentially small circuits on separate breadboards that correspond to textbook logic building blocks.

Recommended IC Families: 74HC or 74HCT (HCT if mixing with any TTL outputs; but at this stage pure CMOS is fine). We avoid 74LS in new designs due to higher power and TTL voltage thresholds, except perhaps using 74LS47 for driving 7-seg if on hand. Otherwise use CMOS + transistor/resistor to drive 7-seg.

Clocking: Use the Stage 0 clock for any sequential circuits (flip-flops, counters). For purely combinational tests, clock is not needed.

Testing: For each small circuit, use switches to provide inputs and LEDs to monitor outputs. E.g., test a half adder: toggle input A and B, check sum and carry LED vs expected truth table. For a D flip-flop: connect an LED to Q, toggle D and send a clock pulse, ensure Q updates only on clock edge. The counter: let it free-run under a  $\sim 1$  Hz clock and observe the binary count on 4 LEDs or on the 7-seg display (which can show 0-9 then letters for A-F). Each IC's function is verified (this also familiarizes students with datasheets and pinouts). This stage instills confidence in using 74xx chips and reading logic diagrams. Safety: ensure not to short outputs together; at this stage, no tri-state yet, so contention isn't an issue as long as outputs only drive LEDs or single inputs.

# Stage 2: Bus Drivers, Adders, and Registers (Core Data Path Components)

Components: 74HC245 (8-bit bidirectional bus transceiver) – useful for connecting sections or simulating a bus; 74HC373 or 74HC574 (8-bit transparent latch or D flip-flop register with tri-state outputs) for general registers; 74HC283 (4-bit binary adder, use two for 8-bit addition) or 74HC181 (4-bit ALU slice, though 283 is simpler if only add); 74HC157 (quad 2-to-1 multiplexer for selecting between two data sources onto bus, e.g., between memory and manual input, as in SAP-1's MAR load logic)  $^{53}$ ; 74HC00 etc. for any needed glue logic (e.g., NAND gates to create control signals). Possibly 74HCFlag register (no dedicated IC; could use a 74HC74 or 74HC273 to store flags bits).

Schematic Blocks: The 8-bit bus: physically, a set of 8 lines running across the breadboard, with bus transceivers or tri-state outputs from registers and memory connected. The A and B registers: implemented by 74HC574 latches with outputs enable-able onto the bus (like AO, BO control lines). The ALU: use two 74HC283 adders to make 8-bit adder; for subtraction, implement using XOR gates to invert B and a mode

control (like the SAP-1 SU signal) 7 . If using 74HC181 ALU slices (if available), those can do multi-logic functions (could be fun for later expansion). Tri-state buffer 74HC245 can be used for the output register (to output data to LEDs or later to an external bus).

IC Families: 74HC series or 74HCT. At this stage, consider that if we eventually interface with W65C816 (CMOS), 74HCT is ideal because 65C816 inputs expect CMOS-level highs (they actually are CMOS, so they expect near 0.7Vcc for high). 74LS outputs only go to  $\sim 3.4$  V which might be borderline as logic '1' for CMOS  $^{54}$ . So using 74HC/T throughout ensures compatibility. If some 74LS chips are used (like 74LS245 could be in parts bin), ensure any CMOS driving them meets TTL input thresholds (should be fine) and any 74LS output that goes into CMOS input is above 3.5 V for logic high (74LS often not ideal for that). Safer to stick to 74HCT which has TTL input and CMOS output levels, good bridging device. For simplicity, specify use 74HCT for bus interfacing chips (transceivers, buffers) when mixing with older TTL devices, otherwise 74HC if all CMOS.

Clocking: The registers and ALU operate combinatorially for the most part, but registers latch on clock or control signals. We will ultimately have a two-phase microcycle (one for "set up operands" then pulse clock for "register in"). However, at this breadboard stage, we often manually trigger register loading with control signals tied to the single system clock or separate manual pulses. Perhaps use a slow clock and have students observe glitching if control signals are not properly timed, to illustrate need for proper synchronous design (but in SAP-1, control signals were derived from microcode and considered combinational with a gated clock). For now, assume a control scheme where we can toggle a control line switch at the right time relative to a slow clock pulse. This is a bit tricky; possibly easier: run clock very slowly and set control lines to high or low statically to effect one operation. E.g., to test  $A = A + B$ : put a value on A latch, another on B latch (control signals AI and BI), then assert the ALU out (EO) and A in (AI) control with clock, etc. We might mimic the microcode manually initially.

Testing: This overlaps with the SAP-1 build testing described in the curriculum. Essentially verify each piece: - The bus: Ensure that when only one device's output enable is on, the bus carries that value (LEDs showing). When multiple outputs accidentally enabled, observe the wrong result or contention (and avoid doing that again!). - The adder: Load register A and B with known 8-bit values, then enable both onto ALU inputs and see the sum output (we may need an output latch to hold ALU result or directly see it on bus LED). For example,  $A = 5$ ,  $B = 3$ , expect sum=8 and check carry flag. If using a flags flip-flop, test zero and carry by setting up appropriate values (e.g.,  $A = F0h$ ,  $B = 10h$  should cause a carry). - The registers: confirm they store correctly. Also test the tri-state behavior: one can put A's outputs on bus and see them, then turn off A's output and turn on B's, see it changes, etc. Use the bus status LEDs to monitor. - Multiplexer (if present for MAR or similar): test it selects correct input by toggling select line. Definition of Done for Stage 2:* We have a working "datapath" capable of holding two 8-bit numbers and computing their sum or difference, and placing the result in a register. Essentially a manual ALU system. This sets the stage for adding a controlled sequence of operations (the control unit) in Stage 3.

# Stage 3: SAP-1 Style ALU and Register File Integration

Components: Using Stage 2 components plus additional needed ones: 74HC173 (4-bit registers) - Ben Eater's SAP-1 used 74LS173 for MAR and IR because they have tri-state outputs and parallel load; we can use 74HC173 similarly for MAR (two of them for 8-bit MAR)  $^{30}$ . 74HC161 or 74HC193 for Program Counter (4-bit counter, possibly pair for 8-bit PC). An EEPROM 28C16 or 28C64 (for microcode storage), and 28C16 for program ROM (or use RAM for program if easier to modify - Eater used RAM for program memory with a manual input mode). Also 74HC138 or 74HC139 decoders for control signal decoding if needed, though we often just use EPROM outputs directly as control lines. If expanding to 256-byte memory, 74HC257 multiplexers used to switch between manual address input and PC (optional). Schematic Blocks: This is the full SAP-1 computer logic as detailed in Ben Eater's schematics  $^{55}$ $^{56}$ . Blocks include: Program Counter (with increment and load ability - load for jump, increment for normal flow), MAR (connected to memory address), RAM ( $16 \times 8$  or larger static RAM for instructions and data), Instruction Register (8-bit, split output:

high nibble to microcode ROM address, low nibble to bus if needed for data) 57 , Controller Sequencer (microstep counter + microcode ROMs outputting control signals) 58 , A and B registers, ALU, Flags, Output register (with 7-seg display or 8-bit LEDs), and clock/step control. Possibly a “Run” and “Program” mode switch if following Eater's design (to manually load RAM via switches) 24 . We might also integrate the improvements like a controlled clock halt in program mode 24 . IC Families: Continue with 74HC/HCT for consistency. The EEPROMs we use are CMOS and work with 5V CMOS levels. If using older EPROM (27C256 etc.), those are also TTL compatible; just ensure timings (they often need a longer access time e.g. 150ns, but at low clock that's fine). Clocking Strategy: The clock goes into the sequencer (microinstruction counter). Many SAP-1 designs effectively use a two-phase clock or gating: They might use one part of the cycle to latch IR, then increment PC, etc. In Eater's design, the microcode controls when PC increments vs when memory is read, etc. We will likely single-step through microinstructions with a push button or slow clock to observe. Could incorporate a clock enable (CE) and a manual pulse capability for safe stepping 16 . Keep frequency low (<< 1MHz, maybe 1kHz or even manual stepping) because of the breadboard capacitances and to allow students to see LED changes. Test Strategy: Test the SAP-1 incrementally: - First, test the memory module in isolation: in Program mode, manually load some values into RAM (via DIP switches or a temporary Arduino programmer) and verify reading them out by forcing addresses on MAR and enabling RO. Ensure no bus contention (only memory or only manual input on bus at a time). - Test PC: clock it and watch it count, test jump by loading a value into it (e.g., use J control and put value on bus). - Then test a single instruction's microsequence. For example, execute an LDA instruction step by step: manually set the memory with an LDA opcode and a data value at the next address, then let the control unit run and verify A gets loaded. Initially maybe use a slow clock and let it run autonomously, checking signals with LEDs or logic analyzer at each microstep. - Run a simple program: the canonical test is the addition program (load from mem14, add from mem15, output) 59 . If the output “42” appears on 7-seg, it's a success. If not, trace through microstates to find where it diverged. Use the defined control signals list 12 as a checklist. Stage 3 is complete when the 8-bit breadboard computer can reliably fetch and execute instructions from its memory, including arithmetic, control flow (JMP, JZ, JC), and output to the display. This roughly mirrors Ben Eater's completed 8-bit breadboard computer 60 61 .

We also consider some hardware best practices here: ensure every IC has a  $0.1\mu \mathrm{F}$  capacitor across VCC-GND near its pins (these decoupling caps were often omitted in hobby builds but we enforce them to improve stability). The breadboard wires should be as short and tidy as possible; use power rails extensively and perhaps sprinkle a few larger electrolytics ( $10~\mu \mathrm{F}$ ) on each breadboard's power rails to smooth any drops. Due to the complexity, this stage might span many breadboards - group them by module and use color-coded wires for bus lines to avoid mistakes.

# Stage 4: Control Unit Microcode Expansion and Instruction Cycle Improvements

(This stage is somewhat integrated with Stage 3 but focuses on refining and expanding the control logic.)

Components: Additional EEPROM(s) if expanding microcode width or depth (for more control signals or more microsteps). Possibly a third 28C16 for control signals if 16 outputs are not enough (Michael Kamprath noted 16 control lines were limiting and 24 would be nicer  $^{25}$ ). A 4-to-16 decoder (74HC154) could be used in lieu of a third EPROM if we want to decode 4 extra microcontrol bits to 16 lines, but EPROM is simpler. Also, consider a 74HC193 4-bit up/down counter if we want dynamic microstep count (Kamprath's improvement of resetting microstep early for shorter instructions  $^{8}$ ). But that can be optional. Blocks: Modify control logic to support new instructions or changes: - If we expanded to 8-bit instruction opcodes, the IR now provides 8 bits to microcode address (instead of 4 in SAP-1). We then likely have microcode addressing like [opcode][step] forming e.g. 12-bit address (if 16 steps) meaning 4096 addresses -> might

need larger EPROM like 28C64. But simpler: keep 4-bit opcode for now, or only modestly increase to accommodate a few new instructions (maybe use an unused opcode like 0x9 for LDB, etc.). - Add control lines for any new hardware: e.g., BO (B register out) which SAP-1 didn't use  $\mathbf{8}$ , but might be needed to do certain operations (Kamprath enabled B-out to allow storing B or using it as an operand for new instructions). - If adding the concept of a Stack Pointer (for later use), incorporate an up/down counter and control signals SP increment/decrement, SP out and SP in. Possibly as an improvement project at this stage if time permits, since subroutines aren't used until 65C816; but introducing a stack in the 8-bit machine could help demonstrate argument passing and is one of the SAP-1 improvement projects  $\mathbf{21}$ . Recommended ICs: Still 74HC/HCT. If implementing a small stack, 74HC16x series counters can serve (or just use RAM and treat one memory region as stack with an index register). Clock: Remains slow. However, if reliability is good, can try to raise frequency to maybe tens of kHz to not have to wait long for programs (though 7-seg display might not capture too fast changes). Usually, it's kept slow for observability. Testing: Verify that the original SAP-1 instructions still work after any expansion changes. Then test new instructions or features one by one. For example, if LDB is added: - Assemble a sequence manually: LDB X, OUT, HLT. Put value in memory at X. Running it should output that value (meaning B got loaded and maybe we modify OUT microcode to output either A or B depending on some flag, or we add a new OI_B control line - design choice). If it doesn't work, debug microcode address mapping and signals. - If a stack pointer was added, test basic pushes and pops in microcode. Possibly just test that SP increments and decrements and points to correct memory addresses by observing the MAR during push/pop operations (this is advanced, likely saved for 65C816 stage, so maybe skip physically implementing SP in TTL, but conceptually cover it). Completion: Stage 4 is done when the breadboard computer is feature-complete in the ways we want before transitioning to using the 65C816. Essentially, the students have possibly exceeded SAP-1: maybe we now have a SAP-2-like computer with 8-bit instructions and more memory (if not already expanded). However, we might decide not to over-engineer here, because the next stage will be to introduce the real microprocessor.

The key pedagogical goal of Stage 4 is ensuring students grasp the fetch-decode-execute cycle thoroughly, and see how adding features (instructions, registers, microcode complexity) exponentially increases difficulty on a homebrew CPU. This naturally motivates adopting a pre-made CPU for the next stage.

# Stage 5: Memory Subsystem - ROM/RAM, Address Decoding, and Bank Switching

Components: Larger RAM chips, e.g. 32KB SRAM (AS6C62256 or CY62256) or even 128KB. A larger EEPROM or Flash for program storage if needed (or continue with smaller if fine). 74HC138 decoders or 74HC139 to decode address high bits to generate chip select signals for ROM vs RAM vs I/O regions. If bank switching: one or two 74HC373/574 as bank registers to hold bank number (for high address bits) 62 39 , plus logic to combine with address lines. Alternatively, some GAL (generic array logic) or CPLD could handle address decoding (but might violate the "obtainable parts" rule if not already in inventory; discrete logic is fine). Schematic Blocks: For the 65C816 system, define a memory map: e.g., $00:0000-$00:7FFF = RAM, $00:8000-$00:FEFF = more RAM or empty, $00:FF00-$00:FFFF = IO and vectors. The decoder will look at address lines A15-A8 perhaps to decide if /RAM_CS or /ROM_CS or /IO_CS is active. On the breadboard, implement this with 74HC138 (3-to-8 decoder): use A15-A13 as inputs to select one of 8 blocks of 8KB, for example. If A15-13 = 111 maybe selects ROM, 110 selects perhaps expansion or nothing, 0xx selects RAM, etc. Wire the outputs to enable lines of memory chips accordingly. If a simpler approach: one can hard-wire ROM enable for addresses above some value using a couple gates comparing A15 etc. (e.g., use OR gates to detect addresses F000-FFFF for ROM as in typical 6502 designs 35 63 ). For bank switching on 65C816: since the CPU has 24 address lines, A16-A23 will likely come from a separate output port on the CPU (the 65C816

multiplexes data and bank address on the same pins at certain phase if I recall). The W65C816 in single-phase mode exposes 16-bit address and a bank byte on data lines during phi2 low. If using the simpler approach, we may latch the bank address from the CPU into a bank latch every cycle (the WDC data sheet suggests how to interface 65816's multiplexed address). Alternatively, run the CPU in emulation (16-bit address) mode initially to avoid dealing with banks on breadboard. But since final goal is  $>64\mathrm{KB}$ , better to design for native mode. Possibly use the W65C816's VPA/VDA signals to separate the phases and latch high address. A simpler hack: use the 65C816's address lines A0-A15 directly, and treat bank bits as always 0 for memory (effectively ignoring  $>64\mathrm{K}$  at first, which is what 65C02 systems did). Then later on PCB we can incorporate full usage. But let's assume we want to teach bank concept: then include a latch (74HC573 8-bit latch) that captures data bus (which carries bank) when a certain signal indicates it (like E signal or VDA/VPA combination). This is complicated, but we can find circuits from Apple IIgs or X16 references where 65816 was interfaced  $\mathbf{\Phi}_{64}$ . Another approach: cheat by using the W65C802 (which is a 65816 in 40-pin DIP that only addresses 64KB directly). But likely we use W65C816S which is PLCC, needing an adapter. IC Families: 74HCT highly recommended here, because the 65C816 outputs are CMOS but TTL compatible in output, and its inputs likely need TTL-level signals (especially control inputs). Actually, W65C816 is CMOS and might require CMOS-level high for some inputs, which 74HCT will provide. Also, bus transceivers 74HCT245 may be used if isolating some sections or interfacing with potentially different voltage logic (not needed if all 5V). Clocking: The 65C816 can run up to 14MHz typically, but on breadboard, we'll run at maybe 1-2MHz max (and likely in a single-phase mode the timing is like 6502, we can treat  $\varphi$ 2 as main). We incorporate the clock oscillator (could use a can oscillator at 1.8432 MHz (commonly available) or a 555 but better a stable square wave now). Possibly include a means to single-step 65C816 (like using BE or RDY pin to pause, or simply gating  $\varphi$ 2 with logic). Testing: Once the 65C816 is hooked to memory: - Basic test: write a known byte to a RAM address and read it back. Without an easy program, how to do that? We might use a small ROM program or force the CPU to do it. A common bring-up sequence: have a ROM at reset vector that does something like load a value into accumulator and store to RAM, then BRK. For initial test, a simpler approach: tri-state the CPU and use an Arduino or manually load RAM then let CPU run. But assuming we have a monitor in ROM from earlier stage, we can just attempt to use it. However, at first, probably simpler: have the ROM code place a pattern in some RAM addresses and then halt (e.g., WAI or endless loop). Then after halting clock, we inspect RAM content with a logic analyzer or LED. But better, incorporate an LED or hex display for address/data bus to watch memory operations. Possibly have 8 LEDs on the data bus to see fetched opcodes, etc., though at  $>1\mathrm{MHz}$  they flicker too fast. For initial slow clocks, could see it. - Once stable, ramp up clock to maybe 1MHz and run a more complex ROM program that, say, tests various RAM locations or does a march test. Validate that no address decoding issues (e.g., that writing in RAM region doesn't affect ROM or I/O). - If bank latch is used: test switching banks by writing to the bank register and ensuring memory accesses then map to the new bank's contents. This might require a custom test program. Perhaps fill bank 0 and bank 1 memory with different patterns and have code that reads from one, sets bank register, then reads from same address now in bank 1, and verify pattern changed. Output result via LED or serial. - Check that ROM is accessible at expected addresses (e.g., monitor residing at $FFxx is reachable). Completion: Stage 5 is done when the memory system for the 65C816 is working on breadboard: the CPU can correctly address RAM and ROM across the chosen address space, and (if implemented) can use multiple banks of memory via a bank register. This stage transitions our project from the limited memory of SAP-1 to a much larger address model, a fundamental shift (16 bytes to 64KB or more). It also highlights Harvard vs Von Neumann: we might physically separate ROM and RAM chips, but they share address/data bus. We discuss that conceptually you can treat code and data separately (like Harvard) even on a Von Neumann architecture by having distinct address ranges or using the 65C816 signals (VDA/VPA) to distinguish (advanced topic: we note those pins exist and how one could attach separate buses for code/data if desired, though we won't fully do that, our memory map keeps them logically separate)  $\mathbf{\Phi}_{33}$ .

Components: 65C22 VIA (Versatile Interface Adapter) – at least two. These provide 16 GPIO lines each, plus two 16-bit timers and a shift register for SPI-like serial 34 . 65C22 is a WDC part (still made) and is 5V CMOS, ideal. 65C21 PIA could also be used (similar simpler chip with just I/O, no timers). 65C51 ACIA (Asynchronous Comm Interface Adapter) for serial (or Maxim MAX3100 or a simple UART). If ACIA not available, we can use one VIA's shift register to implement serial I/O (bit-banging or shift register mode for TX). Also components for video: if using an off-the-shelf video chip like V9958, include it and its dedicated VRAM (128KB video RAM) and oscillator for it, plus level shifters if needed for analog signals. If using a microcontroller for video (e.g., Propeller or Raspberry Pi Pico), have a header to mount it. For sound: YM2149F PSG chip plus an RC filter and audio amplifier (maybe an LM386) and speaker/headphones. Also possibly an SD card socket (with an SPI level shifter if needed, though at 5V we might run SD in 1-bit SPI via VIA outputs with resistor dividers). Blocks: - Serial: memory-map the ACIA at an address (e.g.,  $9F10-$ 9F1F) 65 . Connect its IRQ line to the CPU's IRQ so it can interrupt on received data if desired. If not using ACIA, implement a software UART using VIA: one VIA's CB1/CB2 lines can be used as TX/RX (there are app notes on using 6522 shift register for serial TX at certain baud with timers). Simpler: use a USB-UART cable connected to a VIA port bit and bit-bang a transmit routine (for printing only). But ACIA makes life easier. - GPIO: Use VIA #1 for general purpose – connect its port A to e.g. 8 LEDs (for debugging outputs or a simple 8-bit output register like SAP-1's 7-seg but in binary) and port B to 8 switches or buttons (for user input or DIP config). Also use VIA #1's CA1/CA2 for keyboard strobe if connecting a parallel keyboard or some control signals. - Timers: Use VIA #2's timers for system timing or sound (e.g., toggle an output at certain frequency for simple beep). Could use a VIA to directly generate square wave audio on an output pin and filter it (one channel beeper). But since YM2149F has better sound, maybe use timers for timing events and leave sound to YM. - Sound: The YM2149F has an 8-bit data bus and 2 address/control lines. Map it into I/O space ( $9F20-$ 9F2F perhaps) 65 . It's basically write-only for registers (or has a port read maybe on some models). Connect its analog output through a simple RC low-pass and into an LM386 amp to speaker. If SAM2695 was to be used, it communicates via serial MIDI commands – easier to drive via a VIA SPI or bitbang. But likely YM2149 is straightforward for 3-channel square wave sound. Interfacing YM: just treat like a memory-mapped device where writing to its address register and data register produces sound. - Video: If TMS9918A or V9958 used, map its control ports to I/O ( $9F30-$ 9F3F perhaps) 65 . Provide necessary clock (for TMS9918, a 10.7MHz xtal), and composite video output circuit (just an RCA jack from its output, as those chips generate composite). If VGA via microcontroller, likely that microcontroller will be fed data from the 65C816 either via a parallel interface or SPI. The Commander X16's VERA FPGA had memory that CPU accessed via I/O registers 66 – we can mimic: e.g., have two addresses: VERA_data and VERA_addr registers. For our microcontroller, it could implement an 128x64 framebuffer internally and we write pixels by writing X, Y, Color to it. We should design a simple protocol for whatever video we choose. Because designing a whole video card from scratch is tough, we might postpone full integration until PCB stage; but at Stage 6 we can at least get text output working (via serial or small LCD) and plan the bigger video. Possibly, implement a character LCD (16x2 or 20x4 alphanumeric) now for a simple display (like Kamprath's LCD upgrade 42 ). That uses 6 GPIO lines, easily driven by VIA. This gives a visual output without needing a monitor, great for offline scenario. So Stage 6 can include connecting an HD44780 LCD to VIA port and printing to it from code. IC Families: All these peripherals are CMOS, so 74HCT logic to glue them ensures proper levels. The YM2149F is CMOS version of AY-3-8910, 5V. The V9958 is a CMOS VDP (requires 5V and some 12V for video signals). For analog video, the levels are fine. The 65C22 and 65C51 are WDC CMOS parts. If any old chips are used (like original AY-3-8910 was NMOS TTL), ensure compatibility (YM2149F is TTL-compatible IO). Testing: Test each I/O in isolation: - VIA: Write to its ports, verify output lines toggle (e.g., have LEDs, see them light in binary pattern). Read from its ports with switches, verify CPU reads correct value. Test VIA timer by programming a timer count and enabling its interrupt or output pin

toggle: can use an oscilloscope on VIA's PB7 (often Timer output) to see the square wave of given frequency. - ACIA: If possible, connect to PC and send characters. Write a simple loop that transmits "U" continuously (0x55 pattern) and verify on PC terminal (pattern indicates correct baud and framing). Then try receiving: have PC send and ACIA interrupt or poll to capture byte and maybe store in memory or echo back. If ACIA not available, test bitbang serial by simply toggling an output pin at known baud and see if terminal interprets it (e.g., send 0x55 pattern by code and adjust delay until terminal sees consistent character). Using a known crystal or ACIA with programmable divisor simplifies this drastically. - Sound: Program YM2149 registers to play a tone on channel A. For example, output a middle C frequency value to tone registers, set amplitude, and enable that channel. Use a speaker or headphone to listen for the tone. It might be quiet, so use amplifier as needed. Alternatively, scope the audio pin to see square wave of correct frequency. This verifies address decoding to the chip and the chip's operation. Try all three channels with different frequencies to make a chord, which is a hallmark test for that chip. - LCD: If using char LCD, send initialization commands (we likely write a short assembly/Pascal routine to init and write "HELLO"). Visually confirm text on LCD. If working, we have a reliable way to output messages for debugging the later stages (very useful since it's attached to device itself). - Video (composite): If TMS9918, test by writing to its registers to set a background color, enabling display, etc. See if a stable (even blank) image appears on a TV (the chip will output a solid color or just border if not initialized fully). Ultimately, try to plot something: the 9918 has graphics mode 1 with bitmapped 40x24 patterns or text mode. Possibly load its memory with a known pattern and see on screen. If microcontroller, test by maybe having it generate a test pattern itself first (to ensure the video hardware works standalone), then test communication by sending it a simple command from the 65C816 and see if it responds (maybe blink an LED or change screen color). This might be rudimentary at breadboard stage; possibly left mostly theoretical until PCB stage where the microcontroller/FPGA integration will be more solid. Completion: Stage 6 is done when the core I/O of the system is functional: at minimum, a console output method is working (could be serial or LCD) and input method (keys or serial) is working, so that one can interact with the computer. Ideally, sound chip can make noise and perhaps the groundwork for video is laid (even if not fully exploited yet). Essentially, after Stage 6, our 65C816 computer can operate as a basic machine: we can load programs (via serial or pre-burned) and see output on a user-friendly interface (screen or LCD, not just LEDs). It's a mini operational system albeit without the final bells and whistles.

# Stage 7: Transition to 65C816 Final Architecture – Integration and Advanced CPU Features

Components: Western Design Center W65C816S microprocessor (in final PCB, likely PLCC package). Reset controller (e.g., MCP130 or simple transistor reset) to ensure reliable reset. Oscillator (for target clock frequency, maybe 14MHz canned oscillator or programmable oscillator). Possibly buffers on address/data bus if driving many peripherals (though 65C816 can drive moderate load, but if multiple boards, line capacitance may be high; in PCBs, consider adding 74HCT245 bus transceivers on both address and data busses for robustness, especially if there's a backplane). Interrupt handling logic: the 65C816 has two interrupt inputs (IRQ, NMI). We should logically OR necessary sources (e.g., VIA interrupts, ACIA interrupts) onto the IRQ line (with wired-OR as these are open drain signals, or use 74HC32 OR gate if push-pull outputs). Ensure any interrupt source can be masked/cleared by software to avoid locked-up IRQ. If using NMI for something (maybe power fail or special debug break), include a way to trigger it (could be a push button to simulate NMI or a watchdog). Also, include logic for ML (Memory Lock) and VP (Vector Pull) signals if needed for any bus arbitration or for latching bank; likely not heavily used in our design but make sure they are either handled or not interfering (e.g., WAI/STP usage and RDY/BE signals if we ever use those to pause CPU). Blocks: At this stage, we fully adopt the 65C816 architecture. That means enabling its 16-bit

index/accumulator mode (Native mode) to exploit full 16-bit operations, enabling interrupts properly, and possibly using its new instructions (PEA, JSR (abs,X) etc.). It's more of a software stage but with hardware considerations: e.g., ensure that the vector table at  $\$ FFEA-$ FFFF is in ROM and correct (for native and emulation modes interrupts). Possibly wire the  $MX$  pins if needed (the 65C816 uses software to switch 8/16-bit modes, but on reset it can be forced to emulation if the vector is  $\$ FFFC$  vs  $\$ FFEA$  for native). Ensure the circuit either releases or uses the  $E$  signal properly (on reset  $E$  might be 1 if starting in emulation). If wanting to directly start in native mode, some recommend pulling  $MX$  or some such, but I think it's controlled by the reset vector address (if vector points to FFC0 range, it's emulation, if to FFFx, it's native). Actually, checking: 65C816 always starts in emulation mode, so we will do a software switch (rep instruction to go native). So nothing hardware to do specifically except ensure code does that. Bus timing differences: The 65816 multiplexes bank address on data lines during phase 2 low when not in emulation. If we haven't done so already in Stage 5, the final design should handle that: either by latching bank lines with ALE or using the VPA/VDA scheme. Many designs simply ignore this by staying in emulation mode (which restricts to 64KB). But we want 16-bit, so we must handle it. On PCB, we likely incorporate a transparent latch (e.g., 74HC573) that latches high address bits when  $\varphi 2$  is low, outputting them stable during  $\varphi 2$  high. WDC's dev board solved this to provide non-multiplexed address bus externally  $^{67}$ . We'll replicate that logic (WDC app note suggests using the  $E$  (Enable signal) to latch when low or high appropriately). Testing: This stage overlaps with thorough testing done in earlier integration. But specifically: - Test Native vs Emulation mode: Write a small code to switch to native mode (XCE instruction) and then use 16-bit operations (like set accumulator 16-bit and add two 16-bit numbers). Verify correctness perhaps by storing result to memory and checking it. Essentially verifying that our hardware (latch for address) works - e.g., try writing to memory in bank  $01$  and see that it actually goes there, not to bank  $\$ 00$ . That confirms the address latch for high addresses is functioning. - Test Interrupts: Connect VIA's IRQ output to CPU, enable a VIA timer to timeout and trigger IRQ, write an ISR (interrupt service routine) in assembly that, say, toggles an LED or prints "IRQ". Enable the CPU IRQ (CLI instruction) and see if the interrupt triggers and the routine executes. Because this tests stacking, vectoring, etc., it's a good stress test of system integration (the hardware must route the IRQ line, and software must have correct vector addresses in ROM). Also test NMI if used (maybe tie NMI to a button and see if pressing it jumps to NMI handler). - Test performance: if planning to increase clock, gradually raise clock frequency on PCB (assuming good decoupling and short traces, 4-8MHz should be fine). See if any issues arise (if something fails at higher clock, likely a propagation delay issue in address decoding or banking latch, requiring wait states or faster logic). The 74HCT family typically can do 8MHz easily, if not 14. If any glitch, possibly use the 65C816 RDY input to introduce wait states (pull RDY low to freeze CPU when slow device accessed, though in our design main memory and I/O are all roughly same speed, so no wait needed if under 10MHz). But we could design that if e.g. using slow ROM (150ns) at 14MHz (71ns cycle) not enough, then implement wait state logic for ROM reads. However, modern EEPROM 55ns are available, so likely fine. Completion: Stage 7 is complete when the full 65C816 CPU is running in its intended configuration with advanced features enabled (16-bit mode, bank addressing, interrupts). Essentially, we now have a working "16-bit homebrew computer" on a preliminary level. It may still be on protoboards or wire-wrapped board for some, but all components are identified and tested. It sets the stage for Stage 8, where we finalize form factor, PCBs, and expansions.

# Stage 8: Final PCB Architecture and System Assembly

Components: Largely the same as Stage 7, but now organized into PCB modules. Also consider: power input jack (5V regulator or use USB 5V), maybe a DC-DC for any special voltage (if using analog video requiring 12V, include a boost converter or accept using an external supply for that portion), connectors (SNES controller ports if desired, PS/2 port, audio jack, video connector like VGA/HDMI if microcontroller

outputs that, SD card socket). Also debugging headers: e.g., a 2x5 pin header to attach a logic analyzer or an Arduino-based logic analyzer on key buses (some designs put test headers on address and data lines for logic analyzers – doing so in PCB with proper labeling is helpful). Possibly JTAG header if we include a small CPLD for glue logic to reduce chip count (VERA FPGA is not used as it is a black box that limits educational value). Board organization: Could be a single monolithic board containing everything (like a motherboard of a small computer). But given complexity, might split: e.g., a main board with CPU, memory, and some I/O (serial, VIA, SPI, SD) and expansion connector; a video board that plugs in or is optional (especially if it uses an FPGA or high-speed signals, maybe keep separate); a sound board optional (though YM2149 small enough to just include on main). If using backplane: design the connectors and bus pin assignments carefully (maybe something like Eurocard connectors or simple 2x25 headers). Or use a stacking approach (like Raspberry Pi HAT style). Connectors: ensure they have proper keying or labeling to avoid reverse insertion; put a spare expansion connector for future (with address, data, control lines exposed) for students who might add more devices later (this fosters tinkering beyond curriculum). Provide power connectors (maybe both barrel jack and micro USB for flexibility). If possible, incorporate a power switch and fuse for safety (like polyfuse or 500mA resettable fuse on input). Power distribution: On PCB, use ground fill plane or at least thick ground traces. Decoupling: every IC gets a 0.1uF cap near it. Also, add a few electrolytics (e.g., one 10uF per power input and at each major section of board). If multiple boards, include ground connectors that tie ground between them strongly (maybe ground plane on backplane). If analog audio/video present, route analog signals away from digital switching lines or use ground shielding, and filter supply to analog chips (ferrite bead or small resistor in series with analog VCC and a 10uF+0.1uF to ground to isolate noise). Testing Plan: Already integrated above, but on the PCB likely re-test each module. The validation from Stage 7 would essentially repeat on the final PCBs: run memory tests, I/O tests, etc., because any PCB wiring error or bad solder can cause malfunction. The advantage now is the monitor and Pascal environment exists, so we can use higher-level tests (like run a memory test program rather than toggling manually). Final features: Consider adding test headers for the address bus and data bus (these can be small 8-pin headers that a logic analyzer can plug into – mark them A0-A7, etc.). Perhaps an LED array showing the lower 8 bits of address and data on the final board (like front-panel lite; not strictly needed but educational – could include a 74HC573 latch that captures address on phi2 and drives LEDs, just for visual effect, or simply connect lower address lines to LEDs with buffers). Also consider user-friendly touches: a reset button accessible from outside, maybe a step-through toggle if we include that on final (less likely at high speed). Definition of Done for Stage 8: The PCBs are assembled and when connected form the final game console/computer. It should be possible to plug in a keyboard (PS/2) and monitor, power up the system, and get to the monitor prompt, interact (enter commands or load a program), and run a Pascal program or game on it, seeing output on screen and hearing sound from speaker. Essentially, the final deliverable device is achieved – a 16-bit homebrew computer that one can actually use somewhat like a vintage microcomputer.

At this point, the hardware journey is complete. The student has gone from building a SAP-1 computer on breadboards to assembling a printed circuit board 65C816 computer with modern I/O capabilities. This hardware roadmap stressed best practices at each step (e.g., decoupling, avoiding floating inputs, managing bus contention with tri-states, using proper logic families for voltage-level compatibility [54], and designing for testability). Safety considerations were woven in: low voltages (5V) used throughout to minimize shock risk, fuses on power to prevent fires if shorted, and careful handling of tools during soldering. By Stage 8, the student also learns about the practical constraints of turning a prototype into a "product" - like mechanical layout for connectors, dealing with signal integrity at higher speeds, and ensuring the final boards are robust (with proper power and ground layouts).

# Software Stack Roadmap

Building the software stack for the custom computer is as crucial as the hardware. We start from the lowest-level (machine code monitor) and gradually move to assembler, then high-level language (SuperPascal) and even a simple OS-like environment. The development is iterative, adding layers of software as hardware becomes capable. Below is the planned progression:

# Monitor Program (Firmware) on ROM

Purpose: Provide basic interaction and debugging capability – allow the user to examine memory, modify memory, and load/execute programs without needing external tools. This is the first software a student writes for the new machine.

Features: - Hex Dump/Peek: Given an address (entered via serial or keyboard), display the contents of memory from that address onward  $^{59}$ . E.g., D 0800 10 would dump 16 bytes from \$0800. Useful for verifying if a program was loaded correctly or if a routine wrote expected data.

- Poke: Write a byte value to a given address. E.g., M 2000 3F might modify memory at $2000 to 0x3F. This parallels older machine monitors and is helpful for quick patches or data setup.

- Register Inspect/Modify: The ability to view CPU registers (A, X, Y, PC, SP, Processor Status) and possibly modify them. This is advanced (requires monitor to break execution and use stack for context) but at least reading them after break or step might be done.

- Run/Step: G [address] (go) to start execution at an address, and possibly a single-step feature to execute one instruction at a time (if we utilize the 65C816's RDY or a trap flag). Single-step might be implemented by an NMI triggered after each instruction using the WAI instruction or breakpoints. If too complex, at least implement a G command to jump to user code.

- Program Load via serial: Because our environment is offline-first, we can't assume a PC at runtime, but initially development will be on PC. The monitor should include a simple loader for either Intel HEX or Motorola S-record or even a custom binary format via serial. For example, send a series of bytes with start address and the monitor stores them in RAM. At minimum, a simple protocol: user enters a command to receive bytes, then uses a host to send the binary. The monitor reads them and places them sequentially starting at a specified address. Alternatively, a more user-friendly approach: use an SD card. If an SD card is integrated, a monitor command L "FILENAME" could load a file from FAT on SD into memory (requires a small FAT16 read routine). Possibly we plan to integrate a tiny filesystem read (maybe reuse a simple FAT implementation or restrict to a raw binary image on card for simplicity). Given time, at least provide a raw sector read ability for advanced students to use.

- Basic Editor (optional): Not required, but some monitors included the ability to write assembly in-memory or a mini assembler for quick coding. This might be beyond scope, since we plan an external cross-assembler and high-level language. So the monitor can be simpler, focusing on memory and I/O rather than assembling.

Implementation: The monitor will reside in ROM (likely occupying top of memory in bank $00 or bank $FF depending on mapping). It's largely written in assembly for efficiency and because it must run without any OS support. For reference, Apple I's Wozmon and Kim-1's monitor or MOS "BASIC Input Monitor" can inspire the design (the commands are similar) 68 .

Milestones: - Write minimal monitor that on reset prints a greeting (like "MOS 65C816 Monitor v1.0") on serial or LCD  $^{69}$ , and then waits for input. This verifies the output routine and input routine in ROM.

- Implement a simple Goto (G) command to jump to an address; test by writing a small machine code at a RAM location (via Poke) that, say, jumps back to monitor via a BRK or known trap, then use G to run it. If returns to monitor, success.

- Implement memory display: test by storing known pattern in memory and using the command to see if it prints correctly (comparing to what was stored).  
- Test writing memory: set a value, then read back (via dump or via program) to confirm.  
- Implement load: Could simulate a load by having the monitor call a routine that reads from serial until some terminator (like a simple XMODEM or a length-based protocol). Test by sending a short program from PC and then verifying it's in memory via dump, then executing it.

Citations from sources: The Ullright example gave an "Arduino EEPROM programmer" and also references for how to input programs 11. Also, hackaday noted WDC's sample project blinking a 7-seg as a demonstration of minimal monitor/IDE usage 70. Our monitor is akin to those early monitors.

A well-tested monitor lays the foundation for all further software: it's the "BIOS/bootloader" of our system. It also serves as a fallback if high-level programs crash – students can drop to monitor to inspect state. It remains in ROM so it's always available on reset. We will allocate the high ROM addresses for interrupt vectors and monitor code (so monitor can handle interrupts or system calls if needed).

# Assembler and Toolchain Integration

Plan: Initially, assembly code for our system will be written and assembled on a host PC (cross-assembler). We select a modern assembler that supports 65C816 (such as ca65 in the CC65 suite, or VASM, or the assembler used in X16 project). If possible, provide this assembler to students offline (maybe on their laptops or lab computers). They write assembly, assemble to binary or HEX, then use the monitor to load it onto the device. Over time, as they become comfortable, we might introduce the idea of the computer assembling on its own, but that might be too heavy. Instead, focus on cross-assembly but ensure the process is smooth (maybe even automate sending the file to the board via serial if environment allows – but offline-first means maybe no laptop, however, in a lab they could have one or a RasPi). Possibly allow assembling on a Raspberry Pi (which is offline but a computer, could be part of lab setup).

Assembler Plan: - Define an assembly language syntax consistent with typical 65C816 assemblers (some specific details like the direct page usage, etc.). - Provide students with a macro or include file that defines hardware addresses (like via registers, device addresses) so they can use labels instead of magic numbers. E.g., define VIA1_data = $9F00, etc., so assembly code is more readable.

- If possible, modify an existing assembler's config to treat our memory map segments (like telling assembler which section is ROM vs RAM if needed for assembly-time relocation). But since our platform is static, not much linking needed – we can just assemble absolute code for now.  
- Encourage using the assembler to develop library routines too (like our monitor and later Pascal runtime are written in assembly).

Milestones: - Write a simple "Hello, world" assembly program (that uses OS routines, say the monitor's print routine or directly accesses ACIA) and successfully assemble and run it on hardware. For example:

HELLO:

LDX #$00

. loop:

LDA message, X

BEQ done

JSR $FFxx ; let's say monitor's print char routine

```txt
INX  
BRA .loop  
.done: BRK  
message: .asciiz "Hello world!"
```

Running this prints Hello world then breaks to monitor. This tests that we can call routines and assemble strings, etc.

- Assemble something that uses 16-bit mode instructions to check assembler's handling (like REP #\(30 to switch to 16-bit acc & index, then do 16-bit math). - Possibly incorporate the assembler usage in the curriculum by writing small assembly functions which will later be called from Pascal (to teach ABI). For instance, write an assembly routine to output a number in decimal (which involves division, etc.) - assemble it and link it into the monitor or call from test code.

On-DeviceAssembler(optional):If ambitious,we could implement a resident assembler that runs on the 65C816 itself,but given limited time and our focus on Pascal,this might not be needed.Instead,the educational goal is satisfied by understanding how an assembler works (maybe by looking at a simple one like James Bates's assembler using lex/yacc 47 or a Python script assembler for SAP-1 71 72).We could have an exercise where students modify or extend a simple assembler script for SAP-1 or for a subset of 65C816,just to appreciate how assembly is translated.

Integration to Pascal compiler: The assembler will eventually be used to assemble the output from the Pascal compiler (unless the compiler outputs machine code directly, which is unlikely if it's a simple one - it might output assembly or rely on an assembler). So having a reliable assembler is needed by the time we generate code from Pascal.

# ABI and Calling Conventions

As we move to high-level languages, we need a consistent Application Binary Interface for how functions call each other (be it assembly or Pascal or mixed). We design a convention for our system: - We will likely use the standard C/Pascal convention for 65xx: - Stack grows downward (65C816's stack page is bank 0, $0100-$01FF in emulation or entire 16-bit SP in native for 64KB stack). We'll use the native mode capability of full 16-bit SP so the stack isn't limited to 256 bytes. Probably place stack in bank 0 for now. - Subroutine call (JSR) pushes return address on stack (65C816 does this automatically). We need to handle 16-bit return addresses properly (in native mode, JSR pushes 3 bytes: 16-bit PC and bank byte). - We decide how parameters are passed: likely on stack (Pascal default is often pushing parameters before call, like cdecl in C but Pascal historically used "Pascal" convention - parameters pushed left-to-right and callee cleans. We can choose whichever, but maybe use C-like for familiarity). Possibly keep it simple: - The calling function pushes arguments (right-to-left to simplify supporting C style if ever needed), calls subroutine. Subroutine may remove them or caller does (we can decide callee vs caller cleanup; Pascal often did callee cleanup, C does caller cleanup for varargs support). - Since this is educational and not interfacing with external libraries, either is fine. Pascal usually defined a fixed number of arguments and could do callee cleanup (which is slightly more efficient). Let's choose Pascal style: callee cleans stack (like older Pascal compilers did, or like stdcall convention). - Registers usage: Decide which registers need saving. 65C816 has A, X, Y 16-bit (or 8), plus DBR, D, etc. We can define: A, X, Y are caller-saved (volatile) except maybe one or two for return values. Typically, - Use A (accumulator) for return values if it fits (like returning an integer or pointer), or A and X if returning 32-bit (not often needed in our Pascal). - If our Pascal has functions, they likely return at most an integer or boolean (which fits in A). - X and Y could be used freely by subroutines if caller saved them first if needed, or we can designate one as preserved across calls (less typical on 6502). Perhaps treat all as volatile

(it's simpler, caller saves what it wants to keep). - Data Bank Register (DBR): If we keep all code and data in bank 0 or at least use direct page for globals, we might avoid messing with DBR. But if Pascal program might have static data in another bank, then when accessing global variables, the compiler will use long addressing with a specific bank. We might simply keep DBR=0 for now (or whatever base we use for data) and not change it on calls (unless doing far data). This is a complexity we might downplay in initial design by keeping everything in bank 0 or a known bank for data. - Direct Page Register (DPR): We can reserve Direct Page ($00xx addressing) for frequently accessed variables (like some global or static variables) to speed them up. But that's advanced optimization. Possibly, we set D = $0000 (so direct page is page 0, overlapping zero page addresses, which is fine). Some might want to move D to somewhere else for user stack frame or static storage, but not needed. - Stack: Use the hardware stack for return addresses and also for local variables and saved registers. So a subroutine prologue would often do something like:

SUBROUTINE:  
```txt
PHB ; push data bank if using  
PHX, PHY, etc if needed to preserve (if not caller-saved)  
allocate locals (could do SUB SP, #locals or so)  
... do work ...  
cleanup locals (PLD or add to SP if needed)  
PLY, PLX if saved, PLB if saved  
RTL (return long which pops PC and DBR)
```

Because 65C816 has RTL which pops the bank as well, we might want to ensure we use JSL/RTL for cross-bank calls.

Given our system is relatively simple, we might avoid multi-bank code for now (keep all code in single bank, so JSR/RTS is fine, no need for JSL/RTL). But if our memory is  $>64K$ , code could span banks. Perhaps we treat each Pascal program as running in bank 0 or fixed bank, and OS/monitor in another bank. This detail we can refine depending on how we partition memory for OS vs user programs.

Summary of chosen convention: - Parameters: pushed in order of appearance (Pascal default is left-to-right so that the first parameter is lowest on stack), callee cleans stack. - Return: A register (or A/X if larger) holds return value. - Registers A, X, Y are volatile ( caller saves if needed). - Use JSR/RTS for intrabank calls, JSL/RTL for interbank if we go there (monitor likely in a high bank, user code in bank 0, so crossing might occur - we might standardize on using JSL/RTL for all calls for simplicity, and have all subroutines assume full 24-bit return address on stack). - Interrupts (if any): separate convention - likely save all regs in ISR and use a separate stack if we set one (could use stack in bank 0, or move S to a dedicated system stack during interrupts by setting emulation mode or using the stack register and a known location; to keep simple, we might allow interrupts only in OS/monitor context, not during user Pascal unless advanced).

We document this ABI for students so they can write assembly that interfaces with Pascal routines and vice versa. We also incorporate it in the compiler so it generates code accordingly.

# Pascal Runtime Requirements

Overview: The runtime is the set of low-level support routines and system services that the compiled Pascal programs will rely on. In a typical high-level language, the runtime provides: - I/O routines (write string/char,

read char, etc.) - Memory management (if dynamic allocation is needed - we might not implement full malloc/free in a student project, but maybe simple heap for strings). - Math routines beyond basic CPU instructions (multiplication, division, possibly long arithmetic or floating point). - Utilities like string handling, possibly some trigonometric functions (the prompt mentions fixed-point and trig tables). - Possibly an exception or error handler (maybe not necessary for our simpler environment). - Interface to OS/Monitor if needed (e.g., to call monitor functions from Pascal easily, like to do file I/O if monitor had disk routines - might not go that far).

Strings: Likely Pascal will handle strings as arrays of char or a specific string type. If it's Niklaus Wirth's style, strings might be fixed-length arrays or possibly we use a dynamic approach like C (null-terminated) or length-prefixed. We can keep it simple by using fixed-size static strings or length-prefixed (common in classic Pascal: first byte is length, rest is content). Implement routines for concatenation, comparison if needed. Those can be done in Pascal or assembly. - Provide WriteString routine to output a string (calls character output in loop). - Provide ReadString if input is needed (maybe not heavy focus). - Possibly an implementation of slicing or substring if the language expects it.

I/O: - WriteChar, WriteString, WriteLn (which outputs newline) - WriteInt (to output integer in decimal, requiring divide routine or repeated subtraction - we should implement an efficient one in assembly using division or binary conversion). - ReadChar, ReadInt if we allow input from keyboard - could be implemented but maybe not heavily used in final demos since games might not be text input heavy. But good for completeness.

Math: - Multiplication and Division: 65C816 lacks hardware multiply/divide. We should supply at least  $16 \times 16 \rightarrow 32$  multiply and  $32 / 16 \rightarrow 16$  divide routines, in assembly for speed. They can be classic algorithms (shift-add, etc.). Possibly use algorithms from known sources or even from 6502 math libraries. Not terribly hard (a loop of 16 adding and shifting for multiply; for division, repeated subtraction or a more refined algorithm). - Fixed-point and trig: If doing a game with physics or needing sine/cosine, likely we will not implement actual floating point (we could, but that's a huge undertaking: either write an FP library or integrate something like MicroPython's?). Instead, fixed-point: define maybe a Q8.8 or Q16.16 format for angles or so. More straightforward: use lookup tables: - For sine/cosine: perhaps have a table of sin values for 0-90 degrees in a table (like 91 entries for 0 to 90) scaled by 10000 (or by 256 if 8-bit is enough). Use symmetry to get others. The mention "trig tables" suggests exactly that 73 . - Provide a Sin(angle) function in Pascal that looks up from table (with interpolation if needed) or uses a small series expansion for better precision if desired. But table is simplest. - Possibly a MulFixed(a,b) and DivFixed(a,b) if we choose fixed Q format to multiply and divide and adjust scaling (like if Q8.8, then after multiply 16-bit*16-bit, shift right 8). - For any physics (like gravity simulation), fixed arithmetic plus possibly some square root function might be needed (could approximate or do Newton's method). But given the time, likely we prepare some utility routines and tables for common stuff like sin, cos, maybe arctan if doing angle calc, but maybe not needed. - If there's interest, mention that we could later incorporate actual floating point library (like no HW FPU but could use IEEE library or something like how Apple used SANE on 65816, but that's beyond HS level realistically). - We probably limit to what's needed for the planned demos (e.g., if doing a projectile, need sin for angle, cos for angle, multiplication, maybe no heavy logs or anything). So tailor runtime to those.

SuperPascal Specifics: The original SuperPascal by Per Brinch Hansen had concurrency features (parallel processes, etc.) 74. We likely won't implement concurrency in this project (it's advanced). We might actually be using a simplified subset of that language (the mention "SuperPascal for small machines" suggests

possibly they've already simplified it). Focus on core Pascal: variable declarations, loops, if, procedures/ functions, maybe simple recursion. Possibly exclude advanced things like objects or dynamic allocation beyond simple pointers if at all.

Memory management: If we include any dynamic allocation (like new/dispose or building linked structures), we'd need at least a simple heap manager. That can be just a very naive allocator: e.g., have a preallocated pool and allocate sequentially (no freeing or one-time usage). For teaching, maybe skip dynamic new entirely or restrict it to static allocation. But if say we want to allow creation of linked list nodes, we might implement a simple free-list. Given time constraints, I'd lean to not introducing dynamic memory to high schoolers at first, and stick to static arrays and records. If they need something like a list, implement it statically or with a fixed pool.

Operating System / Monitor Integration: The Pascal runtime may rely on monitor routines for certain things (like to handle an error or to do file I/O if any). Possibly define some software interrupts or just call known ROM routines (we can link to them since we know addresses). E.g., the Pascal Write could simply call the monitor's print routine address if we expose it. But better to have our own routines that might use monitor low-level drivers (like writing to ACIA). As for OS9-like OS: OS-9 was a multitasking OS for 6809 with a lot of complexity (file system, process scheduling). We won't reach that fully, but we can be inspired to have maybe a mini-kernel that could run multiple Pascal programs if we had time (not likely). Instead, the "OS" might just be the monitor program + any simple scheduler for game loop (the game loop itself will be in user program though). If concurrency was attempted: we could implement a cooperative multitasking by having tasks call a Yield procedure that context-switches (saves registers, pick next task context from an array, restore, etc.). This could be a nice stretch goal if a student is advanced, but not required.

Milestones for runtime: - Implement and test WriteInt in assembly: e.g., test for a variety of numbers including negative (if we support negative in Pascal? likely yes since Pascal has integer type). Ensure it prints correct decimal ASCII. Use it in a small Pascal program to print some values. - Implement Mul16 and test: multiply some pairs and print result, compare with known good (or cross-check by doing repeated addition). - Test Sin table: perhaps print sin 0,30,60,90 degrees to see if values align reasonably (given the scaling). - Memory test if doing dynamic: allocate some stuff and inspect addresses or fill data to ensure no overlaps, etc. - Integration test: Write a more complex Pascal program that uses multiple of these runtime features together (like compute sine of 30 using degrees to rad perhaps, etc., or simulate a bouncing ball's position each frame, printing coordinates).

# SuperPascal Compiler Strategy and Extension by Students

Strategy: We plan to use an existing SuperPascal compiler codebase (from Casibbald or the GitHub superpascal project). We will likely cross-compile on a PC (the compiler itself runs on PC) to generate code for our target. Possibly the compiler is written in Pascal or C, we need to compile it with Free Pascal or GCC. The search results indicated a modification to compile under Free Pascal 75, which implies the code is available and maintainable. - We will configure this compiler with a code generator for 65C816. If the provided one doesn't have 65C816 support, we might have to implement it or adapt from 6502. Perhaps the Commander X16 path in the repo suggests they were planning 65C02 codegen 76 and "future path to 65C816" 77. It's possible they only output 6502 code currently. If so, we have choices: - Modify compiler to output 65816 extended instructions for efficiency (maybe not necessary, could run in 6502 emulation mode code just fine but waste potential). - At minimum, ensure it can use 16-bit mode for arithmetic to truly call it 16-bit machine. Perhaps easier approach: since 65C816 is backward compatible, we can initially treat it as a

6502 with more memory. That means use 8-bit operations and 16-bit address values (maybe via long addressing if needed). But to leverage 16-bit registers, we'd want compiler to emit REP/SEP instructions around arithmetic or use 16-bit opcodes. This might be an improvement done gradually. - Possibly compile to 6502 assembly and then assemble that to run on 65C816 in emulation. But that only uses 64KB and 8-bit operations. - The user specifically said "push the limits of 65C816", so better to generate native 16-bit code. That likely means we, or the open-source project, implement a new backend or modify an existing one.

Given time for a high school project, writing a full code generator might be too heavy. Perhaps the open SuperPascal already has something (maybe outputs a stack-based intermediate or P-code? If it was for teaching concurrency, maybe it produced an intermediate pseudo-code that was run on a VM originally). If that's the case, another approach is to write a P-code interpreter in assembly for 65C816 and run that on the machine, rather than generating native code. But that adds overhead and complexity.

However, the phrase "eventually want students to extend the compiler" suggests we will indeed allow them to tweak the compiler source. So likely we go with the native code generation approach to have immediate, tangible results (faster code, direct mapping).

Extensibility: - We can sandbox the possible extensions: e.g., adding a new keyword or a new intrinsic function. - Perhaps after all base features are done, an assignment for students is: "Add a COS function to the language that the compiler recognizes and emits a call to our runtime cos routine." They would go into the compiler's parser, add a case for 'cos', treat it similarly to 'sin', and ensure it links the runtime function. - Or extend the grammar to allow a new type (maybe a simpler one like an 8-bit type or a fixed-point type so they can write with that directly). - Or implement a small optimization (like constant folding in expressions) to show them how compilers can be improved.

We must ensure any such tasks are guided and within reach: the codebase could be complex, but if we pinpoint a simple component (the symbol table or grammar file if it's a YACC grammar), they could make a small change.

Safety & curriculum scope: Because of offline environment, we want the compiler running on teacher's PC or provided to students pre-built. They might not all hack the compiler, perhaps just demonstrate or have a special interest group do it. But providing the source and explanation fosters deeper understanding for those interested.

Milestones: - Get the compiler to produce a simple program's assembly (or machine code) for our system. E.g., Pascal program that sums two numbers. Ensure the output follows our ABI and runs correctly on hardware (possibly tested by printing result). - Compare output vs expectation: maybe manually write assembly for the same program and check if compiler's output is logically equivalent. - Fix any calling convention mismatches or missing runtime calls (maybe we need to adjust how it calls write routines). - Once basic output works, compile one of our earlier demo programs (like the "Hello, Commander X16!" in the Commander X16 readme 78 but targeting our system). Run it successfully. - Then perform an extension: for instance, if the current language lacks the WriteLn procedure, add it as alias to WriteString with newline, or something trivial. Test with a Pascal code using writeln.

Final Software Integration: By the end, the software stack will look like: - Machine Code Monitor (in ROM) - already done in Stage 1 of software. - Basic Input/Output routines (in ROM or runtime library) - e.g., getch, putch, etc. Possibly partly in ROM (monitor) and partly linked in with programs. - Assembly code -

students can write their own for performance-critical parts or hardware access if needed. - Pascal Runtime - a library of routines (some in assembly, some in Pascal, or all assembly for lower-level) that gets linked or included in compiled programs. Possibly reside partly in ROM (for example, the monitor's print could serve as Pascal's writeln, saving space) or as separate code loaded with program if flexibility needed. Using ROM routines means any changes require ROM update, but it's fine if stable. - Pascal Compiler - runs externally to produce programs, which then are loaded onto device.

We will produce a few milestone Pascal programs as mentioned: - LED blink (very trivial in Pascal: a loop toggling a memory-mapped port bit with delay). - Serial print or LCD print "Hello" - just to confirm high-level can call low-level. - Graphical or sound demo - e.g., fill video memory with some pattern or play a melody. This tests how easily the high-level language can handle I/O (likely by calling our runtime procedures like SoundPlay(note)). - A simple game (like guess number text game or interactive fiction maybe, if no graphics yet). - If graphics is ready: a moving sprite or text bouncing on screen (like a screenshot). - Final project game combining physics: e.g., a "Pong" game which has basic collision (requires math and I/O) - ideally in Pascal except low-level pixel/sound calls.

All these are stepping stones verifying different stack elements: - Pong would test keyboard input (paddle move), video drawing (ball and paddles), collisions (some math). - It will rely on our runtime for drawing line or sprite, and for delays (maybe using VIA timer to regulate frame rate). - Possibly use sound to beep on bounce (calls sound routine). - The code structure might be an infinite loop in Pascal with some condition to break (score reached). This kind of program shows the machine can handle realtime-ish tasks with a high-level language, which is quite an accomplishment.

Throughout development, we maintain printed documentation of the instruction set, memory map, calling convention, so students can debug at multiple levels (if Pascal program fails, they might inspect the assembly output or monitor memory to see what went wrong, bridging the theory and practical).

In summary, our software stack goes from a simple monitor to a fully compiled high-level language program on a custom architecture - a full vertical slice of computer science topics (architecture, OS, compilers, algorithms). It's comprehensive, yet we modularized learning so each year/stage is digestible and builds toward this.

# Bill of Materials (BOM) and Cost Model

We outline the parts needed for each stage and estimate costs. We also differentiate between one-time purchases (tools and reusables) vs consumables/unique to each student. The cost model will have a minimal route (just enough to get functionality, sometimes using cheaper or salvaged parts) and an ideal route (with better tools and expansions).

Stage 0-2 BOM (Year 1 basics): - Breadboards: at least 2 full-size breadboards per student by Stage 2 (one for power/clock/Proto, one for small circuits). Cost ~$5 each. Suggest 3 breadboards (~$15). - Jumper wires kit: pre-cut and/or spool. ~$5. - Power supply: Can use a 5V USB charger with a DIY cable to breadboard, or a bench supply for lab. A USB phone charger ($5) plus a breadboard adapter ($2) is cheap. Ideally one bench supply per lab bench ($50 each high quality, or a $15 small one). - Multimeter: one per student or at least per 2 students. Decent ones ~$15 each. - Oscilloscope: optional in minimal route (logic probe or an LED can do some debug). Ideal lab: one oscilloscope per lab or per 2-4 students. A PC USB scope ~$100 or used older analog ones can vary $100-300. If budget strapped, consider using a Salaea Logic clone ($10) for

logic analysis of slow signals, or a DIY Arduino-based scope. (We might suggest the school to invest in a couple if possible). - Logic Analyzer: The 8-channel USB analyzers are ~$10-20, very useful by Stage 3 onward to capture bus waveforms. Ideal to have a few in lab. - Small parts: resistor kit ($10 for assorted values), capacitor kit ($10). Those cover decoupling (0.1uF X many), timing (1nF-100uF), etc. Each student might get a small selection or lab shares a big kit.

• Stage 1 chips: 74HC00,04,08,32,86 (NAND, NOT, AND, OR, XOR) – often come in packs; maybe $0.50 each, $2-3 total. 74HC74 (flip-flop) $0.50, 74HC161 counter $0.75, 74HC138 $0.50, 74HC283 $0.75. A 7-seg display + driver $2. Bulk cost for stage 1 logic around $5 per student set (they often come in variety packs or the educator buys tubes and distributes).

Stage 3-4 (SAP-1) BOM: - Additional breadboards: building full SAP-1 will easily use 6-8 breadboards (Ben Eater's kit uses about that many). So allocate ~5 more boards ($25). - 74LS/HC chips: - 2× 74HC173 (or 74HC573) for IR and MAR ($1 each), - 2× 74HC161 for PC ($1), - 1× 74HC181 or two 74HC283 for ALU ($2), - 3× EEPROM 28C256 (2 for microcode, 1 for program) - $3 each, $9 total (less if smaller capacity, but 28C256 is common). - 2× 74HC245 transceivers for bus ($1), - 1× 74HC157 multiplexer ($0.5) for choosing PC vs manual address if needed, - 1× 74HC257 or second 157 for perhaps controlling IR out etc. ($0.5). - Various gating logic 74HC AND/OR ($1). - Memory: 1 or 2 × 62256 SRAM 32KB ($3 each) or if using vintage 74LS189 for authenticity, $1 each (but better one modern SRAM). - LED display: 7-seg modules (Ben Eater used one 2-digit 7-seg with a latch) - 7-seg ($1) + 74HC573 ($0.5) and resistor pack ($0.5). - Clock: 555 ($0.5) + pot + knob ($1) + toggles ($1). - Estimated cost for SAP-1 specific parts ~ $15 (chips) + breadboards $25 = $40.

Stage 5-8 (65C816 system) BOM: - W65C816S CPU: ~$15 (WDC list price for DIP adapter or PLCC chip maybe $7 plus PLCC socket $3). - Memory: SRAM 128KB $3, EEPROM 32KB $3. Possibly one each needed. If larger flash needed for bank (like if storing monitor + maybe Basic etc. in ROM, 128KB $4). - Glue logic: 74HCT138 decoders ($0.5), 74HCT573 latch ($0.5 for address latch), some 74HCT245 ($1) if bus buffering, OR gates for IRQ ($0.5). - I/O chips: - 65C22 VIA ($6 each from WDC), using two -> $12. - 65C51 ACIA ($6). - YM2149F sound chip ($5, clones might be cheaper). - possibly TL082 op-amp or LM386 for audio amp ($1) + some audio jack ($1). - If TMS9918 video: found maybe on eBay $15 + VRAM chips $5 + oscillator $1. Or a Propeller microcontroller $8. - If using Raspberry Pi Pico for video (has HDMI out hack): $4. - VGA connector or HDMI adapter if needed ($2). - Character LCD (16x2) if used: $5. - SD card socket: $2. - Connectors (PS/2 jack $1, SNES controller connectors if used $2 each, maybe just reuse old controllers). - Misc: PLCC sockets, voltage regulator (7805 or buck $2), DC jack $1, fuse $1, dip switches or jumpers $2 (if any config). - PCBs: depends on size and quantity. For small runs, PCBWay can do e.g. 10 boards 10x10cm for $5 plus shipping $20. If our design is bigger maybe $50 for 5 large boards. Assuming we do mainboard and a couple small boards, maybe $100 total for PCBs for a class (if ordering in bulk). - Tools for PCB: Soldering irons (should have in lab, $20 each for decent adjustable), solder ($10 roll), wire cutters, etc. Possibly logic analyzer as mentioned.

Cost analysis per student vs shared: - Many parts can be shared in lab (like one logic analyzer can serve multiple if scheduled). - Ideally each student (or pair) has their own full setup so they can take home or work independently - but that skyrockets cost for boards. More likely done in lab groups of 2-3. - For minimal route: skip advanced video and sound chips: - Could use just serial terminal for output (so no video chip cost, though maybe have an old VGA monitor and a cheap TTL-to-VGA converter if needed, but one can use PC as terminal). - Omit YM2149, instead just use simple buzzer via VIA toggling (virtually zero cost). - Use single VIA (instead of two) if absolutely needed (one VIA can do a lot but we have to multiplex usage, but it's manageable). - Omit ACIA if cost - can bitbang, but ACIA is more reliable. Or use an Arduino as a serial relay (some do that to avoid ACIA cost, but that's complicated and detracts academically). - For memory, minimal

system can run in 64KB, so maybe skip bank latch if no heavy banking (but we want it educationally). - Possibly salvage older chips (some schools might have old 65C02, but 65C816 less likely). - The microcontroller for video could be optional, as they said baseline breadboard no FPGA, but allowed "optional FPGA/video" - in minimal route, skip that and rely on text LCD or serial only.

Ideal route: - incorporate everything: YM2149 for multi-voice sound, maybe SAM2695 to demonstrate advanced sound (cost ~$15 breakout, optional). - A proper video card: maybe using the FPGA (like X16's Vera if they release, or a mini Spartan board $30, but then student not building that logic themselves – it's more like an add-on). - Plenty of breadboards to not worry about running out (like a big bag $50 for class). - Good quality power supply for stable voltage (a lab supply or a quality 5V 5A supply so multiple boards reliably powered). - Perhaps a small logic analyzer device for each group for debugging (since analyzing 16-bit bus by eye is tough). - Additional components like an LED matrix or 8x8 LED panel for intermediate display fun (couple dollars). - Possibly incorporate a compact flash or SD with FAT, requiring some library – ideal scenario, they can store programs on card and load, which is a modern touch (cost of microSD breakout negligible). - Tools: ideally a digital oscilloscope 100MHz+ ($300) for the lab to catch signals, also a decent logic analyzer like Saleae ($300) with many channels, but that's if budget allows.

Cost summary per student (assuming group share for expensive items): - Basic electronics (breadboards, wires, passives, basic ICs): ~$50 - SAP-1 specific add-ons: ~$30 (EPROMs, more breadboards, etc.) - 65C816 system core (CPU, memory, VIA, glue): ~$40 - I/O chips (ACIA, video, sound, connectors): if all included maybe $40 more - PCB fabrication and assembly: maybe $20 per student if boards shared or small group. - Tools like meter, solder iron: one-time but if each has, add $30; if lab shares, negligible per student.

Minimal path: skip advanced – could come to around  $100-$ 120 per student (if a lot of stuff is shared, maybe less). This yields a working 65C816 with serial output and maybe no fancy graphics but enough to run programs.

Ideal path: including every bell and whistle, plus nice equipment - could approach $300 per student (particularly if individual scope or analyzers not feasible in many school budgets, so those remain lab-only resources).

Cost spikes to note: - The transition from breadboard to PCB (cost of PCBs, plus needing some components like sockets, connectors that might not have been needed on breadboard, and possibly replacing some chips if form factor changed). However, PCBs can reduce cost because you might drop some DIP connectors or shorten wiring (cost is design time more than part cost). - Buying the microprocessor and WDC chips (these are relatively cheap - WDC stuff each, whereas TTI chips are cents if in bulk). - The video solution is uncertain cost: an off-shelf VDP or a microcontroller or an FPGA dev board. That could significantly spike if we insisted on something like a DE0 Nano - but we likely avoid that due to baseline requirement of obtainable parts. A Pi Pico is just and can do DVI out, which is an elegant cheap solution if code is ready. - Tools: initial year might not need an oscilloscope but by year 3 it becomes almost necessary for high-speed signals - hopefully by then school invests or borrows. - Extended memory or expansions: if we decided to add something like an RTC chip for time or network (some homebrew add an Ethernet via SPI, but not asked here - though maybe not needed, but if did, that's extra chip cost). - Rework or replacements: always some chips might burn or wires fail - include some spare costs.

Shared Toolkit Items: - Power supply (could be one bench PSU per 5 students, so cost averaged). - Oscilloscope (maybe one for instructor demos plus the cheap analyzers for student use). - Logic analyzer

(the $10 ones can be one per team, not too bad). - EEPROM programmer if not using Arduino for it. Possibly have one TL866 programmer ($50) in lab to burn EPROMs quicker than student breadboard or Arduino. But with monitor, ideally we won't need to frequently burn EPROMs beyond initial firmware – so maybe teacher programs them before class and any updates if needed. - Soldering station (for PCB assembly and any wired debug). - Safety equipment: ESD mats/wrist straps ($10 each strap, mat $20, ideally each student uses one when handling sensitive chips; minimal route might skip and just caution, but ideal lab uses them). - Magnifier or microscope for soldering (optional but helpful, one in lab $100). - Spare chips (not exactly tool, but teacher should have extras of everything because students will accidentally fry a few – plan ~10% extra in budget for that).

Minimal vs Ideal Summary: - Minimal: Use breadboards for everything, only essential chips (maybe skip sound, skip fancy video, just enough to run text and basic graphics via serial or small display), reuse breadboards from SAP-1 for 65C816 by dismantling (though better to keep SAP-1 intact for reference). Tools minimal (maybe just multimeter and a simple DIY clock tester). Possibly the teacher demonstrates on his scope if needed, but students do mostly LED-debug. This is slower and may cause frustration if bugs can't be seen easily, but it keeps cost low.

- Ideal: Each student group has a full suite (scope, logic analyzer, etc.), full set of I/O on their computer (sound playing actual music, video showing actual graphics on monitor). They can produce something akin to an SNES-level demo by end. The cost/time is higher, but the motivational payoff is huge (e.g., seeing their own graphics on screen with sound that they programmed in Pascal).

Given our goals, we would lean toward at least including sound and some video even if rudimentary, as the final "game console" claim wants. So budgeting accordingly.

Where costs spike: - Year 4 to Year 5 (introducing WDC chips). Years 1-2 mostly cheap TTL, Year 3 maybe $50, Year 4-5 adding CPU and VIAs ($20+), maybe bigger cost if they also do PCBs then. So likely Year 5 or 6 is when they may need to pay for custom boards and pricey chips. Could plan fundraising or phasing: reuse some parts of SAP-1 (like wires, 7-seg, etc., though not much reuse because architecture changed, but some chips like adders might not be needed once 65C816 is used). - If PCBs fabricated individually for each, that's some cost (~$30 each including shipping). - Tools possibly purchased gradually: maybe by Year 5 each group invests in a logic analyzer if needed. Or school provides by then after seeing success of first years.

Managing cost: - Bulk ordering by school reduces per-unit costs. Possibly some parts sampling (some companies give edu samples). - Could salvage from old electronics: e.g., older 65C02 boards might have VIA or ACIA (6522, 6551) to salvage. But 65C816 not common in scrap except SNES (but SNES chips not DIP, not trivial). - Possibly use cheap microcontrollers for some roles to avoid buying rare chips (like using an Arduino as an I/O expander in place of a second VIA or to emulate ACIA - but that complicates conceptual purity though might cut  $\$$ ). - The plan explicitly said "obtainable parts" and uses known families, so likely not to rely on salvage or hard-coded micros except for specific tasks like video.

# BOM per Stage Table (for reference):

<table><tr><td>Stage / Item</td><td>Key Parts &amp; Units</td><td>Approx Cost (USD)</td></tr><tr><td>Stage 0-1: Tools &amp; Basics</td><td>Breadboards (3), wires, resistors, caps, LED pack, multimeter</td><td>$50 (mostly one-time)</td></tr><tr><td>Stage 1: Logic gates experiments</td><td>74HC logic ICs (5-6 types x2 each), 7-seg &amp; driver, switches, 555 &amp; pot</td><td>$10</td></tr><tr><td>Stage 2: ALU &amp; Registers</td><td>Adders (74HC283 x2), Registers (74HC574 x2), bus buffer (74HC245 x2), extra breadboards (2)</td><td>$15</td></tr><tr><td>Stage 3: SAP-1 full build</td><td>EEPROMs (3), Counter (74HC161 x2), IR/MAR regs (74HC173 x2), output latch, additional LEDs, + breadboards (4)</td><td>$30</td></tr><tr><td>Stage 4: (if expanding SAP-1)</td><td>More EEPROM if needed, maybe extra logic for flags, etc.</td><td>$5</td></tr><tr><td>Stage 5: 65C816 core</td><td>65C816 CPU, SRAM, ROM, latch (74HC573), decoders, bus buff</td><td>$25</td></tr><tr><td>Stage 6: I/O devices</td><td>VIA ($6 x2), ACIA ($6), Sound chip ($5) + amp, Video solution ($0-$20 depending choice), connectors (PS/2, jacks, etc $10), SD socket ($2)</td><td>Minimal: $15 (1 VIA + reuse serial via PC), Ideal: $40</td></tr><tr><td>Stage 7: (Integration hardware)</td><td>PCBs (shared cost; maybe $50 for class batch ~ $5 each if many), sockets &amp; headers ($10), extra logic if any (OR gates for IRQ $1)</td><td>$15 (assuming class splits cost)</td></tr><tr><td>Stage 8: (Assembly &amp; extras)</td><td>Soldering consumables (school-provided typically), optional expansions (maybe LCD $5, controllers $10)</td><td>$0-$15 optional</td></tr></table>

Minimal total per student (shared PCBs & tools): Roughly  $150. Ideal per student:$ 250+ with all enhancements.

However, because year-by-year purchase is possible, the cost can be spread: - Year1: maybe $50 per student out-of-pocket (like kit cost). - Year2: another $50 (the SAP-1 kit parts). - Year3: $50-$70 (advanced chips, maybe PCBs, etc. Possibly school covers some at this stage). - Year4: $50 for final expansions.

The hope is some parts carry forward (wires, breadboards from earlier can be reused or repurposed). Also, after building SAP-1, those chips could be reused in final if dismantled (but we might want to keep SAP-1 intact as a reference or for demonstration; we could cannibalize some generic logic like 74HC00 etc from it though since we have extras of those).

Conclusion: We present BOM in such staged manner to teachers/admin to plan budget. Emphasize that initial years require mostly low-cost generic parts, later years need some specialty parts (which could be the only ones needing ordering from a specific supplier like WDC). Potential risk: availability - WDC parts sometimes only direct or via small distributors; plan to order well in advance for year 3. Possibly get a bulk discount or educator's sample.

We mention supply risk and mitigation in next section (like have a fallback if W65C816 not delivered in time - maybe use 65C02 which is easier to source but then cannot meet 16-bit goal fully; or have a plan to borrow chips from any retro computing community if short).

# Risks and Mitigations

# Technical Risks

- Signal Integrity on Breadboards: As frequency and complexity increase, breadboards suffer from noise, capacitance, and tenuous connections  $^{17}$ . Manifestations: the SAP-1 might glitch (e.g., spurious increments due to control signal cross-talk, known 74LS157 glitch issue needed fixing with capacitors  $^{17}$ ). Mitigation:  
- Use short wires and neat layout (bus lines bunched and straight).  
- Liberal use of decoupling capacitors near ICs to stabilize voltage  $^{18}$  (we instruct students to place  $0.1 \mu \mathrm{F}$  for every chip).  
- Limit clock speed on breadboard (keep to a few  $100\mathrm{kHz}$  maximum). If higher needed, consider moving to PCB sooner.  
- In critical cases, add small series resistors (like  $100\Omega$  ) on fast edges to damp ringing, or small capacitors for debouncing control signals (like Eater's fix of 1nF on WE line of RAM to avoid double-triggering  ${}^{79}$ ).  
- If 74HC isn't driving well due to many inputs, use bus drivers (74HC245) to strengthen signals across long bus lines.  
- Reliability improving modifications by community (like using HCT vs LS to match logic levels and reduce required currents, as LS LEDs caused power dips  $^{3}$  - we choose appropriate logic family to avoid that).  
- We will also have students build incrementally and test each module thoroughly (so when adding one wire causes an issue, we know where to look).  
- Clocking and synchronization issues: At various points, asynchronous inputs or poorly timed control can cause erratic behavior (e.g., not meeting setup/hold times for register load signals, or misusing the 65C816's multiplexed bus without latching causing wrong address). Mitigation:  
- Use single master clock and derive all internal timing from it (no multiple asynchronous clocks).  
- For manual operations, ensure transitions occur while clock is stopped or in defined phase (like press a button to assert a control line, then tick clock, etc.).  
- When integrating 65C816, follow recommended bus latch design (use  $\phi 2$  or VPA/VDA signals to latch high address at correct time so that address is valid when needed 67).  
- If using devices like ACIA that might require proper baud clock, supply correct crystal and ensure it's in spec (to avoid framing errors).  
- Provide optional wait-state logic if needed (e.g., if at high speed the ROM is slow, use the 65C816's RDY pin to pause until data ready).  
- Bus contention: If two outputs drive the bus simultaneously (e.g., forgot to disable one device), it can damage chips or at least cause incorrect data (like B and memory both driving data bus). Mitigation:  
- Adhere to the tri-state control discipline: at any microcycle, only one  $RO$ ,  $AO$ , etc. is active 7 . We design microcode carefully and test signals by possibly using an LED for bus to see if multiple sources try to output (bus values would appear intermediate or chips might heat).  
- We can include small resistors  $(\approx 220\Omega)$  in series with each bus output line; this limits short-circuit current if contention happens, giving a safety net at cost of slight speed reduction. Many robust designs include series resistors on data lines as protection.  
- Testing microcode extensively in simulation (maybe using a SAP-1 simulator or writing a simple one in Python) to confirm no two outputs are on in same cycle  ${}^{8}$  .

- ESD (Electrostatic Discharge): Handling CMOS chips in a classroom can lead to static zaps frying chips. Mitigation:  
- Instruct students to discharge themselves (touch metal or use provided wrist straps) before touching ICs.  
- Work on ESD mats if available.  
- Keep chips in anti-static foam when not in use.  
- The cost of a few chips is small, but losing a critical component like the only 65C816 day before demo is a risk. So store spares and handle with care (teacher might keep a few CPU spares locked to avoid unnecessary handling).  
- Overheating/Power issues: Drawing too much power (especially driving many LEDs or using LS chips that sink currents) can overheat regulators or chips. E.g., as one student found, connecting LEDs without resistors overloaded outputs  $^{3}$ . Mitigation:  
- Use current-limiting resistors on all LED connections (explicitly teach that).  
- Use chips within rated current: e.g., each 74HC output can only source  $\sim 6\mathrm{mA}$  at 5V, so if driving LED, use resistor to limit to e.g.  $2\mathrm{mA}$ . If need brighter, use a transistor or buffer.  
- Monitor power rail usage: the 5V regulator is good for maybe 1A if properly heat-sinked. Our system might approach that with many chips. Possibly use multiple regulators or a single higher capacity supply (like use a USB 5V 2A adapter which is well within).  
- Spread power connections: multiple breadboards should each get power from a common distribution with thick wires, not daisy-chained thin wires too far (voltage drop issues).  
- Check chip temperatures with a finger or IR thermometer; if something is hot, likely a wiring mistake (immediate troubleshooting).  
- Include fuses (for PCB stage, a polyfuse or resettable fuse on input) to protect from major shorts.  
- Availability of parts: (This is more supply risk, but technical if not mitigated it halts project). E.g., WDC parts might have lead time. Mitigation:  
- Order critical components well ahead of Year 5. Possibly engage with WDC or distributors for educational pricing/samples.  
- Have backup plan: if 65C816 is not available in time, consider using a 65C02 (limiting to 8-bit but at least continuing with other aspects like video/sound – though it doesn't meet final spec, it could serve interim. Or use an emulator on PC to test software if hardware is late).  
- For less unique parts, always stock extras (chips like VIA, ACIA are still made but not extremely common – get those early; TTL ICs are common).  
- In case of chip failure during demo with no replacement, at least have an emulation environment (maybe a simulator of 65C816 on laptop to run the program and show output) as last resort demonstration, but this is not ideal.  
- Alternatively, if one hardware fails, share another group's hardware for the demo.  
- Complexity cliff in integration: Combining everything (CPU + all peripherals + memory management) might lead to very complex bugs that are hard to diagnose (is it software? hardware? timing?). Mitigation:  
- Keep an up-to-date schematic and use it to systematically check connections if things go awry.  
- Use the testing plan to isolate subsystems: test hardware with small known programs (like self-test routines) before running big Pascal programs. E.g., test video by a small assembly routine that draws border, test sound by playing a tone, etc.  
- Provide or develop some diagnostic programs in monitor/ROM that students can run if something is wrong (like a RAM test pattern fill to check memory, an IRQ test, a sound test sequence).  
- Encourage troubleshootinging with tools: e.g., if Pascal program crashes, use the monitor to see where PC went or what memory values are wrong. Possibly incorporate a simple debug output via serial or blink codes for error states (like monitor could catch an invalid opcode trap and flash an error code).

- If timeline allows, do a practice integration on a smaller scale (like integrate CPU + one VIA + one simple output first, achieve a minimal "computer" that prints via serial; then incrementally add video, then sound).  
- Also we have the SAP-1 improvement path as reference: we can compare our 8-bit machine signals with known patterns  $^{59}$  to see if, say, the fetch cycle is doing what it should. This can catch issues in control logic early rather than when everything is connected.

# Pedagogical Risks

- Dropout / Student Overwhelm: This is a demanding multi-year commitment. If a student falls behind or loses interest (especially at points where debugging is frustrating), they might drop out of the program or disengage. Mitigation:  
- Ensure early wins each term: e.g., blinking LED by week 3, a simple ALU operation by end of term 1, etc., so that students see tangible progress and feel accomplishment frequently.  
- Use a scaffolding approach: The curriculum is iterative; we won't throw them in deep end. Each year reviews prior concepts quickly at the start (so if someone new or someone weak from last year can catch up). For example, year 3 will likely revisit basics of microprocessor when introducing 65C816, relating it to SAP-1 to ground their understanding.  
- Teamwork and mentorship: Have students work in pairs or small teams, so they can support each other. Possibly pair stronger students with those struggling (peer learning). Also encourage older year students to mentor younger (like year4 could present their year1 diaries or help year2 with tricky parts).  
- Project Journal and Debug Logs: Teach students to maintain a log of what they did and observed. This practice helps them slow down and think (less overwhelm) and provides a record to backtrack when something breaks. It's also good for assessment—teacher can see their process and intervene if they notice confusion in logs.  
- Accessible help: Instructor should allocate some open lab times or office hours for one-on-one help, especially during critical build times. If a student is stuck in wiring or understanding, a quick guided nudge prevents long frustration.  
- Alternate paths for failure points: Not all students may complete the ultimate machine fully working by Year4—some might have partial functionality. That's okay; define minimum goals (maybe some students only get text working but not graphics, etc.). They can still learn from it. Provide pre-built modules if needed (e.g., if video is too hard, it's okay to provide a working video board kit for them to integrate, focusing their work on CPU and programming).  
- Keep the excitement by linking to real-world: e.g., mention how their breadboard computer relates to early computers or gaming consoles. Possibly organize a field trip or guest talk (someone from retro computing community or an engineer) to reinvigorate interest at key junctures.  
- Complexity vs Curriculum Fit: There's a risk that the project overshadows other curriculum requirements or doesn't align with exam syllabi. Mitigation:  
- We map many tasks to typical CS/ICT learning objectives (logic gates, binary arithmetic, programming, etc.). Present it that way to admin.  
- Where needed, incorporate theoretical lessons around the practical tasks (for example, when building ALU, also teach Boolean algebra laws which is a typical exam topic, fulfilling that part).  
- If time for project encroaches on exam prep, ensure to integrate exam-relevant content into it. For instance, UK A-level CS has a section on assembly language, machine architecture, etc.—this project covers that thoroughly in an applied way (students will likely ace those questions after this).

- Provide exam practice problems that use the project context (like "Given this microcode from your SAP-1, what does this instruction do?") so they realize their project knowledge is transferrable to tests.

- For GCSE (Year1-2 equivalent), ensure basics like binary logic, simple programming are not overshadowed by hardware build; find balance by perhaps doing heavy building as extracurricular or as controlled course work if allowed. Possibly use some project tasks as part of coursework assessment if that's permitted.

- Uneven Pace Among Students: Some will race ahead, others lag. Mitigation:

- Provide extension tasks (optional improvements) for fast learners (e.g., "Try adding a new instruction to SAP-1" or "Build a 4-bit multiplier circuit using what you learned"). This keeps them challenged while others catch up.

- Provide structured checkpoints for all: each stage has defined outcomes that must be checked by teacher before moving on. That prevents someone from skipping debugging (which they'd pay for later).

- Encourage collaboration: someone who's done early can help someone still debugging (without just giving away answers, but troubleshooting together).

- Possibly have milestone deadlines but flexible within year: e.g., by end of Term1 everyone should have clock, gates working; by end of Year1, ALU working. If someone is behind, allocate time (like after-school lab) for them to catch up with extra guidance.

- Resource constraints affecting learning: If there's only one scope and 10 groups need it, some will have to debug blind or wait long. They might get frustrated or skip thorough testing. Mitigation:

- Stagger tasks such that not all need the scope at once (maybe schedule specific "signal analysis" sessions).

- Encourage using alternative methods for some debugging (like using slow clocks and LED displays to infer signal sequences).

- If budget allows, purchase a few more low-cost analyzers for critical times (they are quite cheap now).

- Possibly make use of simulation for checking parts of design (e.g., use Logisim or a simple digital simulator for the control logic). While hardware is the focus, simulation can verify design logic so hardware debugging is less.

- Senior Year Pressure: By Year4, students have university entrance exams (A-levels) – they might find it hard to devote time to finishing a large project if not managed. Mitigation:

- We integrate the project as their official A-level project (if doing an exam board that requires a practical project, like some do for computing). That way it's not extra but part of their graded work.

- We aim to have most heavy lifting (hardware assembly) done by mid Year4 so that near exams they focus more on software/fine-tuning which is less labor-intensive than soldering or big debug. Also coding can be done at home theoretically, whereas hardware debug requires lab presence.

- Possibly freeze hardware changes by end of first term Year4 and use second term to do mostly software (which also aligns with learning high-level language concepts).

- If needed, accept to not push optional features if time is short - e.g., if HDMI output isn't working by spring, maybe shelve it and ensure at least composite or serial works to demonstrate something, so students aren't scrambling last minute on hardware instead of studying for exams.

# Supply Chain Risks

- Availability of Chips: Already covered partially. Key ones: W65C816, WDC 65xx chips – maybe single source from WDC. Potential mitigation:

- Order at least 6 months in advance for the class, maybe group with another institution to meet any minimum.

- Have alternate sources: e.g., Mouser stocks WDC parts sometimes  $^{80}$ . If WDC had an SXB board (the dev board) maybe consider purchasing one as backup to salvage chip or use if our board fails  $^{81}$  - hackaday mentioned W65C816SXB boards WDC sells; could buy one (\~\$100) to have a reference and spare chip onboard.

- 6522 VIA and 6551 ACIA are also still made but in moderate demand among hobbyists – plan accordingly. If they become scarce, alternative: use Microcontrollers to emulate them or different chip (e.g., 65C22 could be replaced by two 8-bit I/O expanders in worst case, but not with identical functionality).

- Memory chips are usually fine (SRAM and EEPROM widely available).

- Sound chips: YM2149 still produced by Yamaha (or clones by AY). If not, can salvage from old hardware (old Atari STs had YM2149).

- Video chip: TMS9918 and V9958 are long discontinued; must find in retro market if we go that route. Risky supply. Instead using a modern microcontroller for video avoids that risk (RP2040 or Propeller are readily stocked).

- Also consider future: If program runs yearly, keep stock of uncommon parts year to year (like buy a tube of 65C816 and store properly for upcoming cohorts, since WDC might have minimum orders).

PCB fabrication delays: Mitigation:

- Finish PCB design before summer of Year3 to send out early and have in hand by Year4 start. Even better, do a small prototype run at end of Year3 (maybe teacher builds one PCB system over summer to test, so Year4 begins with a proven design).

- Have breadboard backup if PCB not ready or has errors: students still have breadboard prototype to continue some development (though limited performance).

- Possibly use a local PCB fab or faster service if timeline is tight (at higher cost).

- Always double-check footprints and design to avoid costly re-spins – might do a pilot with one board before making  $\sim 10$  for class.

- Cost Overruns: The plan might become expensive, risk school cutting support. Mitigation:

- Use phased purchasing and reuse parts to distribute cost across budgets.

- Seek sponsors or grants (maybe local tech firms or a STEM grant could supply tools or parts).

- Possibly open-source the project and attract community donations or interest (some retrocomputing folks might donate old parts or expertise).

- For students, perhaps incorporate a small fee for those in the elective, or allow them to keep their machine if they pay certain components, making it a personal investment (like how robotics teams often require fundraising).

# Time Risks

- Schedule slip: Each year has limited weeks; risk not all content finished. Mitigation:

- Adjust depth: e.g., if behind in Year2, maybe not implement every SAP-1 improvement, just the basics to move on. We can streamline – since the final goal uses a real CPU, it's okay if SAP-1 is not perfect as long as concept learned.  
- Use some holiday or after-school sessions as catch-up if willing (with incentives like building cool optional gadget).  
- Keep critical path clearly and mark optional enhancements as such (so if short on time, skip them).  
- Project management: teacher should do a mini PERT chart - identify tasks that can be parallel (e.g., writing software can happen while still soldering hardware if someone done earlier, etc.)  
- Possibly involve more people (maybe assign some simpler tasks to interested juniors or club setting).

- Exams and Workload (already touched: mitigate by aligning project with curriculum and not letting it run into exam prep too heavily).  
- Instructor risk: If the instructor is not extremely experienced with hardware, debugging could stall. Mitigation:

- Connect instructor with online communities (6502.org, etc.) for support – so if they hit a snag, they can ask those who've built similar (like many have built Ben Eater's kit, or 65816 systems – references we have).  
The provided primary sources and this roadmap hopefully equip the teacher with enough guidance and references to solve issues.  

- Consider inviting a local engineer or hobbyist to serve as a consulting mentor occasionally (fresh eyes on a tricky bug can help).  
- Also have fallback simpler projects on side so if something in main one becomes untenable, at least students can do something – but since it's multi-year, pivoting is hard. Better to preempt big roadblocks by doing teacher trial runs (teacher building a prototype in advance in summer is hugely beneficial to foresee challenges).

# Mitigation Plans with Alternative Paths

- If any one aspect proves too difficult (e.g., the video output):  
- Alternative video: If HDMI via microcontroller is too complex (timing issues), fall back to simpler composite or just use the char LCD. Or even use an external terminal or PC as display (like having the computer send drawing commands to a PC program that visualizes it – not ideal as standalone, but saves hardware effort).  
- Alternative CPU: If 65C816 gave too many headaches, an alternative could be 65C02 (8-bit) or 16-bit soft CPU in an FPGA (but that contradicts offline/hardware building requirement). But 65C816 difficulties mainly bus multiplexing – which we handle with latch.  
- If running short, we could decide to run the final machine in emulation mode (so treat it like a fast 6502 with more memory). That might simplify some things (no latch needed because just use lower 16-bit address always, ignoring bank, or fix bank=0 via hardware). But then we lose 16-bit registers advantage. It's a compromise: could still have a "16-bit system" in memory width and addressing but not in ALU operations. If time pressed, better to have a working 8-bit mode system than a non-working 16-bit.  
- Optional advanced features: If writing a compiler is too heavy, one could pivot to using an existing cross-assembler and maybe a subset of C or Basic as high-level (like maybe adapt a small BASIC interpreter for 6502 to run on it). But that loses the "Pascal compiler extend" goal.

- Possibly have a pre-written SuperPascal compiler by instructor if students can't complete it, so at least they can use Pascal in final demo. Students still learn conceptually but not from scratch in code.

We will communicate to all stakeholders that iterative approach and these mitigations exist, so minor setbacks won't derail the entire 4-year outcome. That flexibility ensures that by the end, every student will have something working and learned, even if it isn't  $100\%$  of initial dream for some.

# Validation and Testing Plan

We integrate testing at every level to catch issues early. This plan outlines how each subsystem will be tested, largely mirroring what we've described in curriculum but here focusing on methodology and minimal equipment needed.

Stage 0-1 (Basics) Testing: - Use the multimeter to verify the breadboard power rails are at  $+5.0\mathrm{V}$  (within  $0.1\mathrm{V}$  ideally) and ground is at 0. If any anomaly, fix power distribution (maybe poor connection on breadboard, etc.). - For 555 clock: measure frequency by counting LED flashes or using oscilloscope if available. Use frequency formula  $\$f \sim 1.44 / ((R1 + 2R2)C)$  to predict and compare to measured (teaches calibrating). - Logic gates: systematically test each gate IC by constructing its truth table with switches as inputs and LED for output. Students fill a checklist: e.g., for NAND gate IC, try  $(A = 0, B = 0)$ ->LED on? expect on (since NAND of  $0,0 = 1$  82 etc. If any discrepancy, check wiring or chip orientation, etc. This is essentially unit testing each gate type. - Flip-flop: Set  $D = 1$ , clock a pulse (we can simulate a pulse by toggling a wire connected to VCC briefly or using the debounced manual clock), see  $Q = 1$  afterwards. Then  $D = 0$ , pulse, see  $Q = 0$ . Also test asynchronous clear if available. - These simple tests ensure basic ICs are not dead and students wired them right. It's mostly done via LED observation or meter (like meter on output measuring high/low voltage  $\sim 5$  or  $\sim 0$ ). - Provide expected LED results in lab manual so they can self-check (like "for XOR, LED should be on only if one switch is on").

Stage 2 (Adders, Registers, Bus) Testing: - Adder: Use 4-bit adder chips to add various combinations: -  $0 + 0$ ,  $1 + 1$ ,  $5 + 3$ ,  $F + 1$  ( $15 + 1$ ) to test carry. We can use DIP switches or hard-wire inputs for test and use a 8-LED bar for sum+carry. Compare to expected binary sum  $^{13}$ . - We might also chain two 4-bit adders to test an 8-bit sum: e.g.,  $0x28 + 0x14$ , expecting  $0x3C$  and no carry (as in example program  $28 + 14 = 42$  decimal  $^{13}$ ). If we have a 8-bit output display (two 7-seg or 8 leds) and a carry LED, we can validate that scenario. - Register and Bus: - Test that a register (like 74HC574) can capture a value from bus. Do: put a known 8-bit value on bus (with DIP switches or a constant via resistors), then clock "register in" line, remove value from bus (set switches differently or tri-state them), then enable "register out" to bus. The bus should show the original value thanks to register holding it. This verifies the register stores and outputs, and that tri-state control works (when register out disabled, bus should not float to random: in our test, bus might float since DIP switch isn't driving either; we should have pull-down or just check that enabling reg out definitely changes bus to that value). - Perhaps simpler: connect output of register to LED array directly (so bypass bus for test). Load register with a pattern and see LED reflect it. - Test tri-state by enabling two outputs at once intentionally under controlled conditions to see what happens (maybe use resistors to avoid damage). But it's usually enough to emphasize not to do that; if did, measure current or chip heating if any (but better not to). - Bus transceiver (if used by now): Set side A inputs to a pattern, enable transceiver to B side, verify B outputs = A. Then disable and set new pattern on B, enable reverse direction, check A side. This ensures the direction control on 74HC245 works and no shorts (one can do this with one side to DIP switches, other to LED). - We consider using the logic analyzer in parallel for bus operations: e.g., for bus writes sequence: have analyzer on bus lines and control signals, step through an operation, and see timing. But at stage 2, manual stepping is slow enough one can manually correlate, but the logic analyzer can catch glitch if any (like a short bus contention might appear as an intermediate voltage or a quick spike). - Definition of Done Stage 2: Adder sums correctly for all test cases (tick off each in test sheet), register latches reliably, and bus allows passing data from one register to another via that process (complete data path verified). Teacher sign-off after reviewing that their LED outputs matched expected.

Stage 3 (SAP-1 Integration) Testing: - We test the fetch-execute cycle micro-instructions: - First, test program counter alone: Reset it (should go to 0). Then simulate clock with CE (counter enable) and see it count 0,1,2,... on the address LEDs  $^{16}$ . Test jump: set PC inputs to e.g. 5, pulse load (J control)  $^{16}$ , verify PC now outputs 5 and counting from there on next clocks if CE resumed. - Test memory read/write: - If using a small RAM like 16x8 with manual programming: put switches for address and data, load some data into memory (like address 0xE=28, 0xF=14 as in example) using manual controls (set MAR, set data on bus, assert RI control to store etc. The Eater design had a separate "program mode" for this with a stepper). -

Then test memory out: set MAR to those addresses, assert RO and see data appear on bus (connected to 8 LED or an output register). Specifically, address 0xE should output binary 00011100 (28) and 0xF -> 00001110 (14)  $^{83}$ . If not, check memory wiring or address decoding. - If using EEPROM for program memory: we can program it externally with a known pattern (like the example program's bytes) and then read it out by letting SAP-1 run or manually performing fetch cycles. - Test the instruction register capturing: - Put a known instruction in memory at address 0 (say LDA 0xF is 0001 1111b as per table  $^{84}$ ). Manually do a fetch: PC=0, assert CO, MI (place PC on bus, latch into MAR)  $^{16}$ , then RO to put memory onto bus, II to latch IR  $^{85}$ . Now IR should contain 0x1F. Check IR's outputs: high nibble =1 (LDA opcode), low nibble =F (operand). If IR out control is not used (we often don't need to output IR data portion except for microcode counter or operand to MAR), maybe have IR data lines visible or accessible for test (maybe put LED on IR's data nibble outputs if tri-stated possibly use buff). - Then increment PC (CE) and fetch next byte (at 1) presumably or if using two-step memory fetch like the improved design, ensure we've done that micro-step sequence correct. - Microcode ROM: This is hard to test directly but we can verify some control outputs. For instance, at reset microcode counter=0, IR might be 0 (NOP) which usually does minimal signals. If we load a HLT instruction (0xF) and run, microcode should raise HLT line which stops clock. We can test: memory[0]=0xF (HLT), then run through fetch, decode; when execution step comes, see if the HLT control line LED goes high and system stops incrementing. - Alternatively, test a known sequence: load memory with a program (like the addition program from Ullright wiki  $^{83}$ ), then clock the computer free-running (maybe at 1Hz so we can watch step by step). Observe the registers after completion: - In that program, after running, A register should contain sum (0x2A i.e. 42 dec) and output routine would have put that on display before halting  $^{83}$ . So if final Output LED shows 42, success. - We can instrument intermediate steps: e.g., connect flags register to LED to see if zero/carry behave, or step one microinstruction at a time by manual clock to see if it follows the expected sequence from microcode listing  $^{86}$ . - The SAP-1 design being well documented, we can use their sample programs as test vectors: - Add two numbers test (addresses 14+15 as described)  $^{83}$ : At end, the OUT register (7-seg) should display "42". If using binary output, it would show 0010 1010 (0x2A). We confirm registers: A should be 0x2A, memory at 14,15 unchanged (or 15 might have been overwritten depending on program if using STA). - Jump tests: Put a JC (jump if carry) scenario: e.g., do a SUB that triggers carry, then a JC instruction to skip or jump. Check PC final value to see if branch happened or not, depending on carry LED at that time. - Memory store test: Program that uses STA to store A into memory, verify memory changed (e.g., LDI value, STA to location, then maybe HLT, then use monitor or manual read to see memory updated). - Using a logic analyzer on SAP-1: - Connect it to: φ (clock), one or two control signals, and perhaps a couple of bus lines. Step through an instruction, the log will show which control signals went high at which microstep relative to clock edges. Compare with expected microcode timeline  $^{19}$ . This is advanced but nice if equipment available; if not, manual observation suffices since frequency is low. - Once SAP-1 works for a set of small programs (at least: load/ store, add, branch, output, halt), we consider it validated. If any test fails, debug microcode or wiring accordingly. - We define "SAP-1 passed all core tests" as a requirement before moving to adding the 65C816, because we want confidence in those subsystems (ALU, registers, memory) that we will repurpose or at least the knowledge from them.

Stage 5 (Memory/Address Subsystem for 65C816) Testing: - Memory: Before CPU insertion, test memory decoding logic: - Put known patterns in each memory region if possible (like tie address lines and data lines to certain combos, see which chip enable lights). - For example, set A15 high and others low to represent \(8000, check if ROM_CS is activated and RAM_CS not. - A simpler way: once CPU can run, write a pattern to RAM and read back: - Use monitor or a small assembly routine to fill RAM addresses with incremental numbers, then verify by reading out (via monitor dump or via program that compares memory to expected). - If any byte mismatches or errors (like unable to write beyond 0x7FFF if we expected to, etc.),

find decoding/wiring issues. - Check bank switching: if implemented at hardware level, one can manually toggle bank latch inputs and see if different physical RAM chips enable. Or with CPU: write value X to bank0:0xA000, switch to bank1, write value Y to 0xA000, switch back to bank0, verify bank0:0xA000 still X (and not overwritten by bank1's write) \( ^{87} \). If yes, banks are independent. If it was same memory, then bank latch didn't work. - In practice: have a bank register, possibly memory-mapped or an output port, use monitor to change it. Or simpler, if using CPU's own bank (Data Bank reg), a program that loads DBR and writes to memory should show differences in corresponding banks if properly implemented. - CPU handshake: Often first time powering the CPU can be tricky: - Do a reset test: apply reset, release it, and see if CPU does something. With no code, it might wander. But if we have our monitor in ROM, we expect at reset it vectors to start of monitor. - If the monitor has a "sign of life" (like prints a message or turns an LED on), check that happens. If not, use scope/LA to see if CPU is fetching from correct address (monitor start). - Could put a debugging LED on address line A15 for instance: on reset, 65C816 will fetch vector at \(\$ F F F C\) (in emulation mode). That toggles A15 likely as it reads from high addresses. Or use LA on address bus to see if it's trying to fetch from ROM area. - If CPU stuck in reset or not clocking, check clock signal at \(\phi 2\) pin. Check that RDY pin is not held low inadvertently, etc. - Once running, try basic monitor commands: e.g., use it to peek memory at 0000 and see if it matches some known (like the signature bytes of monitor program perhaps). - If no serial or display working yet, maybe embed in monitor a routine to flash an LED connected to, say, VIA port on an error or at certain point to indicate progress. E.g., one flash means "entered monitor code", two flashes means "initialized VIA", etc. This is a fallback for initial bring-up if primary I/O isn't up. - Bus timing: Check that our address latch for high address lines is working: This might require scope/LA: - Look at one high address line (A16) along with \(\phi 2\). See that during \(\phi 2\) low, A16 corresponds to bank from DBR, latched in \(\phi 2\) high (if using latch triggered by \(\phi 2\)). If not done, CPU might put bank during \(\phi 2\) phase 1. If our latch triggers incorrectly, addresses beyond 64K won't appear right. - Another way: write a value to bank1:\(0000 and a different value to bank2:\)0000, then read them back. If our latch didn't latch, CPU would always access bank0 or an undefined combination, causing read back to always show one of them or misread. If we latch correctly, we get distinct values for each bank. - Check also VDA/VPA if we use them (they tell when address is valid for data or program). If used to control latch or other logic, confirm with LA that those signals align (like at opcode fetch VPA=1, etc). - We also test interrupts signal lines at hardware level: - Trigger NMI by pulling it low (wired to a button perhaps) and see if CPU jumps to NMI vector (if we have a routine there, like maybe just sets a memory flag or prints message). - For IRQ: simulate one by either using VIA (like set its IFR bit via software or tie /IRQ pin low momentarily). See if the CPU responds (maybe prints something or sets a known variable). - Need to ensure we properly wired the pull-ups or logic for these lines (like if open drain, use resistor). - Edge cases: test memory at boundaries: - Read last byte of RAM (like \)9EFF$ if that's where RAM ends and IO begins as X16 mapping example \( ^{36} \)) and first IO address to ensure no overlap in decoding. If writing to one accidentally affects other, decoding is wrong. - If using bank switching window approach (like X16's \)A000-$BFFF is banked), test addresses around window edges to ensure only those addresses swap banks and others remain fixed. - At Stage 5 completion, ideally the monitor program can reliably load and run simple programs from base RAM in bank0, and possibly switch banks for larger program. But if not fully integrated, at least have proven hardware memory and addressing correct via these tests.

Stage 6 (I/O) Testing: - Serial/ACIA: - Connect the board to a PC serial (via USB adapter or direct if PC still has COM port). Use 9600 or known baud. - On reset, see if monitor prints greeting to PC terminal. If garbled, likely baud mismatch or wiring error (swap TX/RX lines if needed, or check clock on ACIA). - If nothing, check ACIA's Tx pin with scope if toggling at all. Possibly a stray wiring or mis-set control registers. - Use monitor to send a known character (like pressing a key might echo, or command that prints "OK"). If receiving fails, test ACIA loopback: connect Tx and Rx on board and send data, see if it comes back (that

tests ACIA internal if configured). - Alternatively, if ACIA is troublesome, temporarily bitbang a char out via VIA and see if PC gets it. But assuming ACIA fine, once texting working, we can use it heavily for further debug prints. - VIA: - Using monitor or a small code, toggle a VIA port pin and verify the physical effect: if pin connected to LED, does it blink? If to speaker (just direct, it will tick). - Test reading: connect a wire from VIA port B0 to 5V via a resistor or to GND to simulate input, see if monitor's memory read of VIA register shows bit change. - Test timer: Program timer to generate periodic interrupts or output: - For interrupts: set VIA to generate IRQ on T1 timeout, enable CPU interrupts, see if interrupt routine executes (could increment a memory counter for example). - For output: put VIA in PB7 square wave mode, pick a frequency, measure it with scope or frequency counter. Compare to calculated value from latch. - If timers not working, check clock to VIA (should be  $\varphi 2$ ). - If using VIA for PS/2 keyboard: have keyboard send something (press key) and see if VIA shift register and interrupt flags capture it. That might need a more complex test harness (maybe an LED on VIA's CA1 to see strobe pulses from keyboard). - We likely keep it simpler: assume keyb via serial or not test PS/2 in isolation beyond verifying that pressing key toggles the VIA's input bit (the data line toggling can be seen with LA or maybe reading registers). - Sound (YM2149): - Write to YM registers: e.g., set channel A tone period to a value (~some value for audible ~1kHz), amplitude to mid-level, enable channel A. If correct, a tone should be heard on speaker. If not: - Check that the latch addressing the YM is working: maybe put LA on YM's BC1, BDIR lines to see proper high/low combos for address vs data writes, and on data bus to see that the intended value is present during write. - The YM's output might need amplification: check at chip pin with scope, one should see a square wave toggling at the tone frequency if volume nonzero. If present at chip but not at speaker, amp or filter might be wrong. - Try different channels, or noise channel (set noise register and enable noise to test). - Once one known frequency works, do a little tune or frequency sweep to ensure all bits of period register are effective (like go from low tone to high tone). - Test YM I/O port (if we use it for gamepad or so) by reading/writing those registers if connected. - Video: - If using an LCD: initial test is simpler - "Hello" string to LCD using known library or direct writes. Visual confirmation. - If using composite or VGA output chip: - Start with something easy: e.g., fill VRAM with a pattern and see on screen if any pattern appears (like vertical stripes if VRAM filled with alternating bytes). - Use the chip's known registers to set mode and background color: e.g., set background to bright blue, see if screen turns blue ( if yes, communication with chip is working). - If using microcontroller for video: - First, test microcontroller standalone (maybe programmed with a test card firmware that displays color bars when it starts, to verify it can output to display). - Then test interface: have 65C816 write a command or pixel to an address that microcontroller monitors; check micro sees it (maybe micro can blink an LED when it receives something). - Achieve at least a modest success like change background color via 65C816 command. - For TMS9918: test text mode by writing ASCII to VRAM that correspond to characters, see if they show up. Possibly easier: its default on power might show a pattern or by writing certain regs we could enable a test pattern. Read status registers to ensure CPU can read from it too (like check VDP status bit if sprite collision if we put overlapping sprites, etc.). - Use LA or scope to debug bus if video chip not responding: maybe it's slow requiring wait states, see if our approach respects that (maybe need to assert RDY). - If HDMI and it fails, fall back to simpler output (for demonstration one can route serial output to PC for text as emergency measure to at least show program results). - Integration tests for Stage 6: - Write a small assembly program or use monitor to test all I/O: - Turn on an LED via VIA, send char to serial, play note on YM, and maybe print something to LCD or screen. All in one sequence, to confirm nothing conflicts. If something fails when combined but worked alone, suspect interrupt or addressing conflicts. - Test that interrupts from different sources don't conflict (e.g., if both ACIA and VIA can fire IRQ, ensure our vector dispatch can differentiate or if we just poll in monitor, ensure that works). - If using SD: try to read a known sector and see if data matches what you wrote on PC. This will validate SPI routine or bitbang via VIA. If issues, logic analyzer on SPI lines can show if clock and data as expected, etc.

Stage 7 (Full System Integration) Testing: - At this point, many tests were done. Now test the system as a whole: - Run a simple user program that uses multiple features: e.g., program that prints a message, blinks an LED, and then waits for key press to play a tone. This goes through CPU, memory, serial, VIA, YM, etc. It should behave on all fronts. - Put some load: e.g., calculate a factorial of 5 in Pascal and print result (120) - test stack usage, subroutine calls, and math. Compare result to expected. - If OS has context switch or multiple tasks (optional): simulate two tasks toggling different LEDs or printing alternating messages to ensure scheduler works (no deadlocks). - Memory robustness: run a memory test program in Pascal: allocate an array, fill with pattern, verify. Or if dynamic memory, allocate sequentially and then free in another order, then allocate again, and check if data persists where it should or freed sections reused - basically a mini fragmentation test if we implemented heap. - Multi-interrupt scenario: e.g., allow VIA timer to generate periodic interrupt to increment a tick count while main program simultaneously doing serial I/ O. Check that no crash, and tick count increments at expected rate (verifiable by printing it every few seconds). - Performance test: If we aim to run at  $>1\mathrm{MHz}$ , test if any operation breaks at new speed: - Possibly run an intensive loop at 1MHz and then at 8MHz, see if output still correct (some timing-critical code like bitbang might fail if assumptions wrong; or external chip might not handle faster accesses - e.g., YM2149 might need delays between register set and data write, which at very high CPU speed might violate if not accounted). - We add waits if needed or adjust code (like after writing YM address port, do a few NOPs). - Long run test: Let the system run a program for an hour (like a demo loop or playing music, etc.) to detect any thermal or stability issues (like memory corruption over time might indicate marginal timings or power issues). - If an issue arises only after extended run, suspect maybe slight overheating or an uninitialized pointer etc. But soak test is nice if time permits to be sure it's not fragile. - Final user acceptance test: can a student (or someone not the builder) follow a set of steps to use the system reliably? e.g., "Turn on, type LOAD GAME, press enter" - does it load and run? Essentially check that user interface (monitor commands, etc.) are working as documented and handle wrong inputs gracefully (like if user tries to dump memory out of range, monitor should not crash). - Document any known limitations so that if something minor isn't fixed, at least users know not to do that (e.g., "Sound and video cannot be used simultaneously at full performance due to CPU limits - if we notice frame drop, tune X").

Unit-style tests summary: We did units like ALU, registers, etc. As we progressed, tests became more integrated. We should maintain a test checklist at each milestone: - ALU operations (Add, Sub, flags) - pass - Register load/store - pass - SAP-1 instruction set (each instruction tested with at least one example) - all pass - Memory R/W in 65C816 - pass for various addresses - Each peripheral function - pass (list them) - Combined scenarios - pass.

Definition of Done gates: - Before moving from breadboard to PCB: require a stable operation of the system at moderate clock (maybe 1-2MHz if possible on breadboard, or at least stable at lower but concept proven at high via logic simulation). - All features intended must have been demonstrated in some form. If something didn't work on breadboard, either fix it or decide to leave it out of PCB (e.g., if PS/2 keyboard reading didn't pan out, maybe commit to using serial console keyboard). - We freeze the design once tests are satisfactory - then go to PCB meaning no new features, just implement what we tested. - After PCB assembly: test core functions with same test cases as breadboard to ensure nothing broke in translation. Possibly the PCBs might allow higher clock - test incrementally raising speed (watch for problems). - Have a review checklist e.g.: - "Can system run monitor from ROM? - Can it load program from SD? - Can it execute Pascal program with loops, if, procedure call? - Do sound and video produce expected output? - Are interrupts processed? etc." All must be yes (except anything purposely omitted with note). - Only then we declare the final computer fully operational.

Testing with minimal equipment: We emphasized using LED, multimeter, maybe cheap LA. The only time a high-bandwidth scope is truly needed might be if chasing a nanosecond glitch – but at our slow speeds, logic analyzer and careful stepping usually suffice. So even in offline no expensive gear scenario, the plan covers verifying most aspects by clever use of what's available (though having at least one scope in the school is strongly recommended for the analog parts like clock integrity or audio shaping).

Software testing: - We will test each piece of software as we build: - Monitor: a script of commands to try and expected outcomes (like automated if possible using PC sending commands via serial and checking responses). - Assembler: assemble known test assembly code and verify output bytes match manual assembly. - Compiler: compile a set of sample programs (some trivial, some complex like recursion or large loops) and run them either on hardware or in an emulator to check correct behavior. Since running all on hardware could be slow, maybe use a 65C816 emulator for logic verification of compiled code results, then just spot-check a few on real hardware to ensure no env issues. - We can incorporate a test harness: e.g., a memory of expected outputs and a program that prints results for those inputs, and then we compare with expected. But given time, likely more ad-hoc testing by trying typical tasks.

- A potential approach: write a few unit tests in Pascal, like:

```txt
function add(a,b:integer):integer;   
begin add  $\coloneqq$  a+b; end;   
begin if add(2,3)  $= 5$  then writeln('OK') else writeln('FAIL');   
end.
```

Then see "OK". Do similar for other operations, covering each language construct and runtime function. This flushes out compiler or runtime bugs.

Memory test rig (if suspicious of memory integrity): - Could have a program fill memory with pattern 0x55, then with 0xAA, then random, verifying after each (common memory test algorithms). If fails at certain addresses, likely hardware wiring issue at those address lines or data bit. - We would do that early in Stage5 to ensure our bigger memory is reliable (addresses & data lines all correct).

Finally, once all tests are green, we can be confident to demonstrate to audience (teachers, fair, etc.) with minimal risk of surprise (though always have a backup demo or video of a previous success run in case Murphy strikes during a live demo – e.g., a keyboard cable fails last minute, etc., so we can still show what it does).

With this thorough validation plan, each subsystem's integrity is verified and system integration is done methodically, greatly increasing chance that the final combined machine works as intended and any bugs are manageable to troubleshoot.

# Next Actions (First 30 Days Kickoff)

To successfully launch this ambitious 4-year program, we should take several concrete steps in the next month:

1. Assemble a Core Team and Define Roles: Identify interested teachers (CS, physics, electronics) who can support various aspects (hardware, software, curriculum alignment). Brief school administrators on the plan and obtain their support/resources commitment (e.g., budget for parts, possibly scheduling lab times). If possible, involve an IT technician or lab assistant who can help manage equipment and ordering.  
2. Inventory and Order Preliminary Supplies: Conduct a quick inventory of what the school already has (breadboards, multimeters, basic logic gates, etc.). Based on that, place orders for Year 1 essential components:  
   - Breadboard kits (including jumper wires)
   - Basic TTL/CMOS IC pack (AND, OR, XOR, NAND, NOT, flip-flops, counters, 555 timers)
   - LED indicators, resistors (lots of  $330\Omega$  for LEDs, 1k-10k for pull-ups, etc.), capacitor assortment (including many  $0.1\mu \mathrm{F}$  decoupling)
   - Tools: if lacking, order multimeters, a modest bench power supply, wire stripper, small screwdrivers, ESD wrist straps. These should arrive within a few weeks. (Cost is relatively low for these basics.) 88
7. Download and Prepare Reference Materials: Print or obtain the critical reference docs:
   - Ben Eater's 8-bit computer schematics and explanations 55.
   - Ullright SAP-1 notes 90 and instruction set table 91 for class distribution.
   - WDC 65C816 Datasheet and Programming Manual (for teacher reference initially; students will need it around Year 3).
   - SuperPascal language report by Per Brinch Hansen and any documentation from the GitHub project (to understand the compiler's requirements). Compile these into a course binder or digital folder accessible offline to students (since they may not have internet during use). We might also include a basic Logisim or digital simulator if available offline, for early logic simulation tasks.
12. Set Up a Project Workspace: Ready the lab with dedicated area for this project. Mark storage for each student's hardware so they can leave partially built circuits safely (like boxes or drawers per group to avoid disassembly each session). Set up anti-static mats on benches if possible. Ensure power outlets or USB chargers for each bench. Arrange a common PC or laptop with the necessary software (assembler, logic analyzer software, serial terminal program) and ensure it doesn't require internet after installation. For instance, install TeraTerm or PuTTY for serial comm, logic analyzer drivers for Saleae clone, Logisim for logic sim (runs offline), and later on the cross-assembler and Pascal compiler environment (maybe Free Pascal which can compile the compiler, and a text editor or IDE for code). Validate all software licenses are fine for educational use.

13. Pilot the Year 1 Activities: Before students begin, the instructor (and any assisting teacher) should walk through Year 1 tasks themselves. For example, build the simple 555 clock and a few logic gate circuits  $^{92}$ , to foresee any tricky points (maybe realize students might confuse resistor values or orientation of LED). Do the half-adder build and confirm the truth table results  $^{82}$ . The instructor should attempt the Stage 1 and 2 tests outlined (maybe in an accelerated fashion) to ensure understanding and to be able to demonstrate or troubleshoot during class. If time allows, also assemble the SAP-1 clock and one register to test ahead of students. Essentially, a mini rehearsal of the first term's practicals.  
14. Curriculum Mapping Meeting: Within first two weeks, meet with the curriculum coordinator or department head to align this project's milestones with required curriculum outcomes. For example, confirm that by end of Year 1, we will have covered the logic gates and binary arithmetic part of GCSE syllabus (which our plan does)  $90$ . Identify if any exam content is not naturally covered by the project so that separate lessons can be scheduled. Also plan how to assess the project progress in a way that can contribute to grades (maybe via project portfolio or practical exam). Get approval for using some hours for this project work (if replacing some standard lessons, ensure it meets learning objectives).  
15. Student Recruitment and Kickoff Session: If not already in a class, advertise this "Build Your Own Computer" program to current Year 9 or Year 10 students (top set in sciences perhaps) to recruit motivated students (the user says assume A stream, so likely already identified). Host an introductory meeting or assembly highlighting the end-goal (show a video or images of Ben Eater's computer lights blinking  $^{59}$ , maybe a SNES running - "we aim to build something akin to this!") to excite them. Explain commitment and benefits (unique skills, fun of games they create, etc.). Provide a simple prerequisite reading or assignment to gauge their initial knowledge and to ensure they're prepared (like basic binary/hex quiz, or ask them to install Logisim and create a 2-bit adder virtually).  
16. Plan the Parts Procurement for Later Stages: Although Year 3 parts (like W65C816, VIAs) won't be used immediately, it's wise to plan their procurement now due to possible long lead times. Check distributors for stock; if low, consider ordering within next 2-3 months and storing. Also line up a PCB manufacturer; maybe test out by ordering a small board (like a simple clock PCB or an adapter) to familiarize with their process and shipping time. Possibly engage senior students or a teacher with PCB design experience to start capturing the SAP-1 schematic in KiCad as a learning exercise (not necessarily to produce PCBs, but to train for when designing the 65C816 board in Year 3).  
17. Connect with the Online Community: In the first month, join forums like 6502.org, Reddit's r/ beneater, or Vintage Computer forum. Introduce the project and seek any tips or resources. These communities can be valuable if obscure issues arise and often are excited to help education projects. They might even have spare parts or code to share (for example, someone might have already ported a Pascal to 6502 that could be adapted).  
18. Establish Documentation and Version Control: Start a project log (could be on a wiki or simple shared document) where we keep track of decisions, designs, test results, and changes. This log will be invaluable for continuity year to year. Also, set up a repository (even local offline in the lab or on a memory stick) for code - e.g., a Git repo for the SuperPascal compiler modifications and any assembly code we develop. Even though offline, we can use a local git server or just instruct

students to frequently back up their code on multiple drives. This prevents losing work and teaches version control.

Within 30 days, ideally: - All initial hardware for Year1 is in hand. - The teacher has built and tested at least the first practical themself. - Students have had their first lessons building simple circuits and are enthusiastic (like blinking LED success by end of first couple of weeks). - Administrative alignment achieved (so project can proceed without bureaucratic hurdles). - A clear timeline for the first year is posted (so students see the path: by October we do X, by December Y). - And communications are open (with any external mentors or online communities).

These steps ensure the program starts on strong footing, with materials, planning, and support ready. Once momentum builds with early successes, we can keep that going into the more challenging phases.

With these foundations laid in the first month, the project is officially kicked off and on track. Now the stage is set to follow through the roadmap year by year, adjusting as needed but always keeping the ultimate goal in sight: a student-built 16-bit SuperPascal computer and game console, and the profound educational journey that achieves it.

``mermaid flowchart LR; A[Logic Gates & Flip-Flops] -> B{4-bit ALU<br/>and Registers}; B -> C[SAP-1 Breadboard<br/>8-bit Computer]; C -> D[65C816 Integration<br/>(16-bit CPU System)]; D -> E[Final Console:<br/>Video, Audio, Pascal OS];``

1 2 31 34 35 49 54 63 67 68 70 80 81 Review: Single Board 65C02 And 65C816 Computers | Hackaday

https://hackaday.com/2015/07/29/review-single-board-65c02-and-65c816-computers/

3 4 18 50 52 82 88 89 92 Making an 8-Bit Computer : 20 Steps - Instructables

https://www.instructables.com/Making-an-8-Bit-Computer/

5 6 7 8 9 11 12 13 16 19 20 22 25 26 27 29 30 39 40 41 53 59 60 61 62 83 84 85 86 87   
90 91 Ben Eater 8 Bit Breadboard Computer SAP1

https://www.ullright.org/ullWiki/show/ben-eater-8-bit-computer-sap1

10 My Expanded Version of the 8-Bit Breadboard CPU : r/beneater

https://www.reddit.com/r/beneater/comments/14j0fk2/my_expanded_version_of_the_8bit_breadboard_cpu/

14 15 21 23 24 28 42 46 58 93 GitHub - michaekamprath/eater-sap-1-improvements: Improvements and modifications made to the Ben Eater SAP-1 breadboard computer

https://github.com/michaelkamprath/eater-sap-1-improvements

Fixing the 74LS157 Signal Integrity Problem on the Eater SAP-1 ...

https://www.youtube.com/watch?v=W2w9KVmyxRs

32 36 37 38 44 45 64 65 66 69 73 76 77 78 README.md

https://github.com/casibbald/SuperPascal/blob/d3452cda35edfb1d9a54fc390191727326a96533/platforms/CommanderX16/README.md

33 Learning the 65816 cycle penalties

https://forums.nesdev.org/viewtopic.php?t=22339

43 Homemade Retro 16-bit Computer with 65C816 - YouTube

https://www.youtube.com/watch?v=jgMxO3W5qBE

47 GitHub - jamesbates/jcpu: Diagrams & code for my home-built Ben Eater inspired 8-bit CPU

https://github.com/jamesbates/jcpu

48 74 Superpascal language - Pascal for small machines

http://pascal.hansotten.com/per-brinch-hansen/superpascal-compiler/

51 75 SuperPascal modification - compiles under fpc (Free Pascal). - GitHub

https://github.com/octonion/superpascal

55 56 71 72 GitHub - dangrie158/SAP-1: Simple as Possible CPU Architecture

https://github.com/dangrie158/SAP-1

57 GitHub - KarenOk/SAP-1-Computer: Design and Implementation of a Simple-As-Possible 1 (SAP-1) Computer using an FPGA and VHDL.

https://github.com/KarenOk/SAP-1-Computer

79 6502 computer project kits - Ben Eater

https://eater.net/shop
